<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>URL | Node.js 中文文档 | Node.js 中文网</title>
  <meta name="description" content="Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。">
  <link rel="stylesheet" href="static/css/style.css">
  <link rel="stylesheet" href="static/css/sh.css">
  
  <link rel="apple-touch-icon" href="static/picture/apple-touch-icon.png">
  
  
  

</head>
<body class="alt apidoc" id="api-section-url">
  <div id="content" class="clearfix">
    <div id="column1" data-id="url" class="interior">
      <header>
        <h1>Node.js v8.x 中文文档</h1>
        <hr>
      </header>

      <div id="toc">
        <h2>目录</h2>
        <ul>
<li><span class="stability_2"><a href="#url_url">url</a></span><ul>
<li><span class="stability_undefined"><a href="#url_url_strings_and_url_objects">URL 字符串与 URL 对象</a></span></li>
<li><span class="stability_undefined"><a href="#url_the_whatwg_url_api">The WHATWG URL API</a></span><ul>
<li><span class="stability_undefined"><a href="#url_class_url">Class: URL</a></span><ul>
<li><span class="stability_undefined"><a href="#url_constructor_new_url_input_base">Constructor: new URL(input[, base])</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_hash">url.hash</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_host">url.host</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_hostname">url.hostname</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_href">url.href</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_origin">url.origin</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_password">url.password</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_pathname">url.pathname</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_port">url.port</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_protocol">url.protocol</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_search">url.search</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_searchparams">url.searchParams</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_username">url.username</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_tostring">url.toString()</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_tojson">url.toJSON()</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#url_class_urlsearchparams">Class: URLSearchParams</a></span><ul>
<li><span class="stability_undefined"><a href="#url_constructor_new_urlsearchparams">Constructor: new URLSearchParams()</a></span></li>
<li><span class="stability_undefined"><a href="#url_constructor_new_urlsearchparams_string">Constructor: new URLSearchParams(string)</a></span></li>
<li><span class="stability_undefined"><a href="#url_constructor_new_urlsearchparams_obj">Constructor: new URLSearchParams(obj)</a></span></li>
<li><span class="stability_undefined"><a href="#url_constructor_new_urlsearchparams_iterable">Constructor: new URLSearchParams(iterable)</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_append_name_value">urlSearchParams.append(name, value)</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_delete_name">urlSearchParams.delete(name)</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_entries">urlSearchParams.entries()</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_foreach_fn_thisarg">urlSearchParams.forEach(fn[, thisArg])</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_get_name">urlSearchParams.get(name)</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_getall_name">urlSearchParams.getAll(name)</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_has_name">urlSearchParams.has(name)</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_keys">urlSearchParams.keys()</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_set_name_value">urlSearchParams.set(name, value)</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_sort">urlSearchParams.sort()</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_tostring">urlSearchParams.toString()</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_values">urlSearchParams.values()</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlsearchparams_iterator">urlSearchParams[@@iterator]()</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#url_url_domaintoascii_domain">url.domainToASCII(domain)</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_domaintounicode_domain">url.domainToUnicode(domain)</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_format_url_options">url.format(URL[, options])</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#url_legacy_url_api">Legacy URL API</a></span><ul>
<li><span class="stability_undefined"><a href="#url_legacy_urlobject">Legacy urlObject</a></span><ul>
<li><span class="stability_undefined"><a href="#url_urlobject_auth">urlObject.auth</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_hash">urlObject.hash</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_host">urlObject.host</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_hostname">urlObject.hostname</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_href">urlObject.href</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_path">urlObject.path</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_pathname">urlObject.pathname</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_port">urlObject.port</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_protocol">urlObject.protocol</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_query">urlObject.query</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_search">urlObject.search</a></span></li>
<li><span class="stability_undefined"><a href="#url_urlobject_slashes">urlObject.slashes</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#url_url_format_urlobject">url.format(urlObject)</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_parse_urlstring_parsequerystring_slashesdenotehost">url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</a></span></li>
<li><span class="stability_undefined"><a href="#url_url_resolve_from_to">url.resolve(from, to)</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#url_percent_encoding_in_urls">Percent-Encoding in URLs</a></span><ul>
<li><span class="stability_undefined"><a href="#url_legacy_api">Legacy API</a></span></li>
<li><span class="stability_undefined"><a href="#url_whatwg_api">WHATWG API</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
<div id="apicontent">
        <h1>url<span><a class="mark" href="#url_url" id="url_url">#</a></span></h1>
<!--introduced_in=v0.10.0-->
<div class="api_stability api_stability_2"><a href="documentation.html#documentation_stability_index">稳定性: 2</a> - 稳定的</div><p><code>url</code> 模块提供了一些实用函数，用于 URL 处理与解析。
可以通过以下方式使用：</p>
<pre><code class="lang-js">const url = require(&apos;url&apos;);
</code></pre>
<h2>URL 字符串与 URL 对象<span><a class="mark" href="#url_url_strings_and_url_objects" id="url_url_strings_and_url_objects">#</a></span></h2>
<p>一个 URL 字符串是一个结构化的字符串，它包含多个有意义的组成部分。
当被解析时，会返回一个 URL 对象，它包含每个组成部分作为属性。</p>
<p><code>url</code>模块提供了两套API来处理URLs：一个是Node.js遗留的特有的API,另一个则是通常使用在web浏览器中
实现了<a href="javascript:;">WHATWG URL Standard</a>的API.</p>
<!--The `url` module provides two APIs for working with URLs: a legacy API that is
Node.js specific, and a newer API that implements the same
[WHATWG URL Standard][] used by web browsers.-->
<p><em>请注意</em>: 虽然Node.js遗留的特有的API并没有被弃用，但是保留的目的是用于向后兼容已有应用程序。因此新的应用程序请使用WHATWG API。
<!--*Note*: While the Legacy API has not been deprecated, it is maintained solely
for backwards compatibility with existing applications. New application code
should use the WHATWG API.--></p>
<p>WHATWG与Node.js遗留的特有的API的比较如下。网址<code>&apos;http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&apos;</code>上方是由遗留的<code>url.parse()</code>返回的对象属性。网址下方的则是由WHATWG <code>URL</code>对象的属性。
<!--A comparison between the WHATWG and Legacy APIs is provided below. Above the URL
`'http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'`, properties of
an object returned by the legacy `url.parse()` are shown. Below it are
properties of a WHATWG `URL` object.--></p>
<p>WHATWG URL的origin属性包括<code>protocol</code>和<code>host</code>,但不包含<code>username</code>、<code>password</code>.
<!--*Note*: WHATWG URL's `origin` property includes `protocol` and `host`, but not
`username` or `password`.--></p>
<pre><code class="lang-txt">┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                                            href                                             │
├──────────┬──┬─────────────────────┬─────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │        host         │           path            │ hash  │
│          │  │                     ├──────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │   hostname   │ port │ pathname │     search     │       │
│          │  │                     │              │      │          ├─┬──────────────┤       │
│          │  │                     │              │      │          │ │    query     │       │
&quot;  https:   //    user   :   pass   @ sub.host.com : 8080   /p/a/t/h  ?  query=string   #hash &quot;
│          │  │          │          │   hostname   │ port │          │                │       │
│          │  │          │          ├──────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │        host         │          │                │       │
├──────────┴──┼──────────┴──────────┼─────────────────────┤          │                │       │
│   origin    │                     │       origin        │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴─────────────────────┴──────────┴────────────────┴───────┤
│                                            href                                             │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
(请忽略字符串中的空格，它们只是为了格式化)
</code></pre>
<!--Parsing the URL string using the WHATWG API:-->
<p>利用WHATWG API解析一个URL字符串:</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL =
  new URL(&apos;https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&apos;);
</code></pre>
<p>在浏览器中，WHATWG <code>URL</code>在全局总是可用的，而在Node.js中，任何情况下打开
或使用一个链接都必须事先引用&apos;url&apos;模块：<code>require(&apos;url&apos;).URL</code></p>
<!--*Note*: In Web Browsers, the WHATWG `URL` class is a global that is always
 available. In Node.js, however, the `URL` class must be accessed via
require('url').URL`.-->
<!--Parsing the URL string using the Legacy API:-->
<p>通过Node.js提供的API解析一个URL:</p>
<pre><code class="lang-js">const url = require(&apos;url&apos;);
const myURL =
  url.parse(&apos;https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&apos;);
</code></pre>
<h2>The WHATWG URL API<span><a class="mark" href="#url_the_whatwg_url_api" id="url_the_whatwg_url_api">#</a></span></h2>
<div class="api_metadata">
<span>新增于: v7.0.0</span>
</div><h3>Class: URL<span><a class="mark" href="#url_class_url" id="url_class_url">#</a></span></h3>
<p>浏览器兼容的 <code>URL</code> 类，根据 WHATWG URL 标准实现。[解析URL的示例][]可以在标准本身里边找到。</p>
<p><em>注意</em>: 根据浏览器的约定，<code>URL</code> 对象的所有属性都是在类的原型上实现为getter和setter，而不是作为对象本身的数据属性。因此，与[遗留的urlObjects][]不同，在 <code>URL</code> 对象的任何属性(例如 <code>delete myURL.protocol</code>，<code>delete myURL.pathname</code>等)上使用 <code>delete</code> 关键字没有任何效果，但仍返回 <code>true</code>。</p>
<h4>Constructor: new URL(input[, base])<span><a class="mark" href="#url_constructor_new_url_input_base" id="url_constructor_new_url_input_base">#</a></span></h4>
<div class="signature"><ul>
<li><code>input</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 要解析的输入URL</li>
<li><code>base</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> | 
            <a href="#url_the_whatwg_url_api" class="type">&lt;URL&gt;</a> 如果“input”是相对URL，则为要解析的基本URL。</li>
</ul>
</div><p>通过将<code>input</code>解析到<code>base</code>上创建一个新的<code>URL</code>对象。如果<code>base</code>是一个字符串，则解析方法与<code>new URL(base)</code>相同。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;/foo&apos;, &apos;https://example.org/&apos;);
  // https://example.org/foo
</code></pre>
<p>如果<code>input</code>或<code>base</code>是无效URLs，将会抛出<code>TypeError</code>。请注意给定值将被强制转换为字符串。例如：</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL({ toString: () =&gt; &apos;https://example.org/&apos; });
  // https://example.org/
</code></pre>
<p>存在于<code>input</code>主机名中的Unicode字符将被使用<a href="javascript:;">Punycode</a>算法自动转换为ASCII。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://你好你好&apos;);
  // https://xn--6qqa088eba/
</code></pre>
<p><em>Note</em>: This feature is only available if the <code>node</code> executable was compiled
with <a href="intl.html#intl_options_for_building_node_js">ICU</a> enabled. If not, the domain names are passed through unchanged.</p>
<h4>url.hash<span><a class="mark" href="#url_url_hash" id="url_url_hash">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置URL的分段(hash)部分。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org/foo#bar&apos;);
console.log(myURL.hash);
  // 输出 #bar

myURL.hash = &apos;baz&apos;;
console.log(myURL.href);
  // 输出 https://example.org/foo#baz
</code></pre>
<p>包含在赋给<code>hash</code>属性的值中的无效URL字符是[百分比编码][]。请注意选择哪些字符进行百分比编码可能与[url.parse()][]和[url.format()][]方法产生的不同。</p>
<h4>url.host<span><a class="mark" href="#url_url_host" id="url_url_host">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置URL的主机(host)部分。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org:81/foo&apos;);
console.log(myURL.host);
  // 输出 example.org:81

myURL.host = &apos;example.com:82&apos;;
console.log(myURL.href);
  // 输出 https://example.com:82/foo
</code></pre>
<p>如果给<code>host</code>属性设置的值是无效值，那么该值将被忽略。</p>
<h4>url.hostname<span><a class="mark" href="#url_url_hostname" id="url_url_hostname">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置URL的主机名(hostname)部分。 <code>url.host</code>和<code>url.hostname</code>之间的区别是<code>url.hostname</code><em>不</em> 包含端口。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org:81/foo&apos;);
console.log(myURL.hostname);
  // 输出 example.org

myURL.hostname = &apos;example.com:82&apos;;
console.log(myURL.href);
  // 输出 https://example.com:81/foo
</code></pre>
<p>如果给<code>hostname</code>属性设置的值是无效值，那么该值将被忽略。</p>
<h4>url.href<span><a class="mark" href="#url_url_href" id="url_url_href">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置序列化的URL。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org/foo&apos;);
console.log(myURL.href);
  // 输出 https://example.org/foo

myURL.href = &apos;https://example.com/bar&apos;;
console.log(myURL.href);
  // 输出 https://example.com/bar
</code></pre>
<p>获取<code>href</code>属性的值等同于调用<a href="#url_url_tostring"><code>url.toString()</code></a>。</p>
<p>将此属性的值设置为新值等同于<a href="#url_constructor_new_url_input_base"><code>new URL(value)</code></a>使用创建新的<code>URL</code>对象。<code>URL</code>对象的每个属性都将被修改。</p>
<p>如果给<code>href</code>属性设置的值是无效URL，将会抛出<code>TypeError</code>。</p>
<h4>url.origin<span><a class="mark" href="#url_url_origin" id="url_url_origin">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取只读序列化的URL origin部分。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org/foo/bar?baz&apos;);
console.log(myURL.origin);
  // 输出 https://example.org
</code></pre>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const idnURL = new URL(&apos;https://你好你好&apos;);
console.log(idnURL.origin);
  // 输出 https://xn--6qqa088eba

console.log(idnURL.hostname);
  // 输出 xn--6qqa088eba
</code></pre>
<h4>url.password<span><a class="mark" href="#url_url_password" id="url_url_password">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置URL的密码(password)部分。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://abc:xyz@example.com&apos;);
console.log(myURL.password);
  // 输出 xyz

myURL.password = &apos;123&apos;;
console.log(myURL.href);
  // 输出 https://abc:123@example.com
</code></pre>
<p>包含在赋给<code>password</code>属性的值中的无效URL字符是[百分比编码][]。请注意选择哪些字符进行百分比编码可能与<a href="#url_url_parse_urlstring_parsequerystring_slashesdenotehost"><code>url.parse()</code></a>和<a href="#url_url_format_urlobject"><code>url.format()</code></a>方法产生的不同。</p>
<h4>url.pathname<span><a class="mark" href="#url_url_pathname" id="url_url_pathname">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置URL的路径(path)部分。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org/abc/xyz?123&apos;);
console.log(myURL.pathname);
  // 输出 /abc/xyz

myURL.pathname = &apos;/abcdef&apos;;
console.log(myURL.href);
  // 输出 https://example.org/abcdef?123
</code></pre>
<p>包含在赋给<code>pathname</code>属性的值中的无效URL字符是[百分比编码][]。请注意选择哪些字符进行百分比编码可能与<a href="#url_url_parse_urlstring_parsequerystring_slashesdenotehost"><code>url.parse()</code></a>和<a href="#url_url_format_urlobject"><code>url.format()</code></a>方法产生的不同。</p>
<h4>url.port<span><a class="mark" href="#url_url_port" id="url_url_port">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置URL的端口(port)部分。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org:8888&apos;);
console.log(myURL.port);
  // 输出 8888

// 默认端口将自动转换为空字符
// (HTTPS协议默认端口是443)
myURL.port = &apos;443&apos;;
console.log(myURL.port);
  // 输出空字符
console.log(myURL.href);
  // 输出 https://example.org/

myURL.port = 1234;
console.log(myURL.port);
  // 输出 1234
console.log(myURL.href);
  // 输出 https://example.org:1234/

// 完全无效的端口字符串将被忽略
myURL.port = &apos;abcd&apos;;
console.log(myURL.port);
  // 输出 1234

// 开头的数字将会被当做端口数
myURL.port = &apos;5678abcd&apos;;
console.log(myURL.port);
  // 输出 5678

// 非整形数字将会被截取部分
myURL.port = 1234.5678;
console.log(myURL.port);
  // 输出 1234

// 超出范围的数字将被忽略
myURL.port = 1e10;
console.log(myURL.port);
  // 输出 1234
</code></pre>
<p>端口值可以被设置为数字或包含数字的字符串，数字范围<code>0</code>~<code>65535</code>(包括)。为给定<code>protocol</code>的<code>URL</code>对象设置端口值将会导致<code>port</code>值变成空字符(<code>&apos;&apos;</code>)。</p>
<p>如果给<code>port</code>属性设置的值是无效字符串，但如果字符串以数字开头，那么开头部位的数字将会被赋值给<code>port</code>。否则，包括如果数字超出上述要求的数字，将被忽略。</p>
<h4>url.protocol<span><a class="mark" href="#url_url_protocol" id="url_url_protocol">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置URL的协议(protocol)部分。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org&apos;);
console.log(myURL.protocol);
  // 输出 https:

myURL.protocol = &apos;ftp&apos;;
console.log(myURL.href);
  // 输出 ftp://example.org/
</code></pre>
<p>如果给<code>protocol</code>属性设置的值是无效值，那么该值将被忽略。</p>
<h4>url.search<span><a class="mark" href="#url_url_search" id="url_url_search">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置URL的序列化查询(query)部分部分。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org/abc?123&apos;);
console.log(myURL.search);
  // 输出 ?123

myURL.search = &apos;abc=xyz&apos;;
console.log(myURL.href);
  // 输出 https://example.org/abc?abc=xyz
</code></pre>
<p>任何出现在赋给<code>search</code>属性值中的无效URL字符将被[百分比编码][]。请注意选择哪些字符进行百分比编码可能与<a href="#url_url_parse_urlstring_parsequerystring_slashesdenotehost"><code>url.parse()</code></a>和<a href="#url_url_format_urlobject"><code>url.format()</code></a>方法产生的不同。</p>
<h4>url.searchParams<span><a class="mark" href="#url_url_searchparams" id="url_url_searchparams">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="#url_class_urlsearchparams" class="type">&lt;URLSearchParams&gt;</a></li>
</ul>
</div><p>获取表示URL查询参数的<a href="#url_class_urlsearchparams"><code>URLSearchParams</code></a>对象。该属性是只读的；使用<a href="#url_url_search"><code>url.search</code></a>设置来替换URL的整个查询参数。请打开<a href="#url_class_urlsearchparams"><code>URLSearchParams</code></a>文档来查看更多细节。</p>
<h4>url.username<span><a class="mark" href="#url_url_username" id="url_url_username">#</a></span></h4>
<div class="signature"><ul>
<li>
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>获取及设置URL的用户名(username)部分。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://abc:xyz@example.com&apos;);
console.log(myURL.username);
  // 输出 abc

myURL.username = &apos;123&apos;;
console.log(myURL.href);
  // 输出 https://123:xyz@example.com/
</code></pre>
<p>任何出现在赋给<code>username</code>属性值中的无效URL字符将被[百分比编码][]。请注意选择哪些字符进行百分比编码可能与<a href="#url_url_parse_urlstring_parsequerystring_slashesdenotehost"><code>url.parse()</code></a>和<a href="#url_url_format_urlobject"><code>url.format()</code></a>方法产生的不同。</p>
<h4>url.toString()<span><a class="mark" href="#url_url_tostring" id="url_url_tostring">#</a></span></h4>
<div class="signature"><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>在<code>URL</code>对象上调用<code>toString()</code>方法将返回序列化的URL。返回值与<a href="#url_url_href"><code>url.href</code></a>和<a href="#url_url_tojson"><code>url.toJSON()</code></a>的相同。</p>
<p>由于需要符合标准，此方法不允许用户自定义URL的序列化过程。 如果需要更大灵活性，<a href="#url_url_format_url_options"><code>require(&apos;url&apos;).format()</code></a>可能更合适。</p>
<h4>url.toJSON()<span><a class="mark" href="#url_url_tojson" id="url_url_tojson">#</a></span></h4>
<div class="signature"><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>在<code>URL</code>对象上调用<code>toJSON()</code>方法将返回序列化的URL。返回值与<a href="#url_url_href"><code>url.href</code></a>和<a href="#url_url_tostring"><code>url.toString()</code></a>的相同。</p>
<p>当<code>URL</code>对象使用<a href="javascript:;"><code>JSON.stringify()</code></a>序列化时将自动调用该方法。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURLs = [
  new URL(&apos;https://www.example.com&apos;),
  new URL(&apos;https://test.example.org&apos;)
];
console.log(JSON.stringify(myURLs));
  // 输出 [&quot;https://www.example.com/&quot;,&quot;https://test.example.org/&quot;]
</code></pre>
<h3>Class: URLSearchParams<span><a class="mark" href="#url_class_urlsearchparams" id="url_class_urlsearchparams">#</a></span></h3>
<div class="api_metadata">

</div><p><code>URLSearchParams</code>API接口提供对<code>URL</code>query部分的读写权限。<code>URLSearchParams</code>类也能够与以下四个构造函数中的任意一个单独使用。</p>
<p>WHATWG <code>URLSearchParams</code>接口和<a href="querystring.html"><code>querystring</code></a>模块有相似的目的，但是<a href="querystring.html"><code>querystring</code></a>模块的目的更加通用，因为它可以定制分隔符（<code>＆</code>和<code>=</code>）。但另一方面，这个API是专门为URL查询字符串而设计的。</p>
<pre><code class="lang-js">const { URL, URLSearchParams } = require(&apos;url&apos;);

const myURL = new URL(&apos;https://example.org/?abc=123&apos;);
console.log(myURL.searchParams.get(&apos;abc&apos;));
// 输出 123

myURL.searchParams.append(&apos;abc&apos;, &apos;xyz&apos;);
console.log(myURL.href);
// 输出 https://example.org/?abc=123&amp;abc=xyz

myURL.searchParams.delete(&apos;abc&apos;);
myURL.searchParams.set(&apos;a&apos;, &apos;b&apos;);
console.log(myURL.href);
// 输出 https://example.org/?a=b

const newSearchParams = new URLSearchParams(myURL.searchParams);
// 上面的代码等同于
// const newSearchParams = new URLSearchParams(myURL.search);

newSearchParams.append(&apos;a&apos;, &apos;c&apos;);
console.log(myURL.href);
// 输出 https://example.org/?a=b
console.log(newSearchParams.toString());
// 输出 a=b&amp;a=c

// newSearchParams.toString() 被隐式调用
myURL.search = newSearchParams;
console.log(myURL.href);
// 输出 https://example.org/?a=b&amp;a=c
newSearchParams.delete(&apos;a&apos;);
console.log(myURL.href);
// 输出 https://example.org/?a=b&amp;a=c
</code></pre>
<h4>Constructor: new URLSearchParams()<span><a class="mark" href="#url_constructor_new_urlsearchparams" id="url_constructor_new_urlsearchparams">#</a></span></h4>
<p>实例化一个新的空的<code>URLSearchParams</code>对象。</p>
<h4>Constructor: new URLSearchParams(string)<span><a class="mark" href="#url_constructor_new_urlsearchparams_string" id="url_constructor_new_urlsearchparams_string">#</a></span></h4>
<div class="signature"><ul>
<li><code>string</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 一个查询字符串</li>
</ul>
</div><p>将<code>string</code>解析成一个查询字符串, 并且使用它来实例化一个新的<code>URLSearchParams</code>对象.  如果<code>string</code>以<code>&apos;?&apos;</code>打头,则<code>&apos;?&apos;</code>将会被忽略.</p>
<pre><code class="lang-js">const { URLSearchParams } = require(&apos;url&apos;);
let params;

params = new URLSearchParams(&apos;user=abc&amp;query=xyz&apos;);
console.log(params.get(&apos;user&apos;));
  // 输出 &apos;abc&apos;
console.log(params.toString());
  // 输出 &apos;user=abc&amp;query=xyz&apos;

params = new URLSearchParams(&apos;?user=abc&amp;query=xyz&apos;);
console.log(params.toString());
  // 输出 &apos;user=abc&amp;query=xyz&apos;
</code></pre>
<h4>Constructor: new URLSearchParams(obj)<span><a class="mark" href="#url_constructor_new_urlsearchparams_obj" id="url_constructor_new_urlsearchparams_obj">#</a></span></h4>
<div class="api_metadata">
<span>新增于: v7.10.0</span>
</div><ul>
<li><code>obj</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a> 一个表示键值对集合的对象</li>
</ul>
<p>通过使用查询哈希映射实例化一个新的<code>URLSearchParams</code>对象，<code>obj</code>的每一个属性的键和值将被强制转换为字符串。</p>
<p><em>请注意</em>: 和 <a href="querystring.html"><code>querystring</code></a> 模块不同的是, 在数组的形式中，重复的键是不允许的。数组使用<a href="javascript:;"><code>array.toString()</code></a>进行字符串化时，只需用逗号连接所有的数组元素即可。</p>
<pre><code class="lang-js">const { URLSearchParams } = require(&apos;url&apos;);
const params = new URLSearchParams({
  user: &apos;abc&apos;,
  query: [&apos;first&apos;, &apos;second&apos;]
});
console.log(params.getAll(&apos;query&apos;));
  // 输出 [ &apos;first,second&apos; ]
console.log(params.toString());
  // 输出 &apos;user=abc&amp;query=first%2Csecond&apos;
</code></pre>
<h4>Constructor: new URLSearchParams(iterable)<span><a class="mark" href="#url_constructor_new_urlsearchparams_iterable" id="url_constructor_new_urlsearchparams_iterable">#</a></span></h4>
<div class="api_metadata">
<span>新增于: v7.10.0</span>
</div><ul>
<li><code>iterable</code> 
            <a href="javascript:;" class="type">&lt;Iterable&gt;</a> 一个元素时键值对的迭代对象</li>
</ul>
<p>以一种类似于<a href="javascript:;"><code>Map</code></a>的构造函数的迭代映射方式实例化一个新的<code>URLSearchParams</code>对象。<code>iterable</code>可以是一个数组或者任何迭代对象。这就意味着<code>iterable</code>能够使另一个<code>URLSearchParams</code>，这种情况下，构造函数将简单地根据提供的<code>URLSearchParams</code>创建一个克隆<code>URLSearchParams</code>。<code>iterable</code>的元素是键值对，并且其本身也可以是任何迭代对象。</p>
<p>允许重复的键。</p>
<pre><code class="lang-js">const { URLSearchParams } = require(&apos;url&apos;);
let params;

// Using an array
params = new URLSearchParams([
  [&apos;user&apos;, &apos;abc&apos;],
  [&apos;query&apos;, &apos;first&apos;],
  [&apos;query&apos;, &apos;second&apos;]
]);
console.log(params.toString());
  // 输出 &apos;user=abc&amp;query=first&amp;query=second&apos;

// 使用Map对象
const map = new Map();
map.set(&apos;user&apos;, &apos;abc&apos;);
map.set(&apos;query&apos;, &apos;xyz&apos;);
params = new URLSearchParams(map);
console.log(params.toString());
  // 输出 &apos;user=abc&amp;query=xyz&apos;

// 使用generator函数
function* getQueryPairs() {
  yield [&apos;user&apos;, &apos;abc&apos;];
  yield [&apos;query&apos;, &apos;first&apos;];
  yield [&apos;query&apos;, &apos;second&apos;];
}
params = new URLSearchParams(getQueryPairs());
console.log(params.toString());
  // 输出 &apos;user=abc&amp;query=first&amp;query=second&apos;

// 每个键值对必须有两个元素
new URLSearchParams([
  [&apos;user&apos;, &apos;abc&apos;, &apos;error&apos;]
]);
  // 抛出 TypeError [ERR_INVALID_TUPLE]:
  //        每一个键值对必须是迭代的[键，值]元组
</code></pre>
<h4>urlSearchParams.append(name, value)<span><a class="mark" href="#url_urlsearchparams_append_name_value" id="url_urlsearchparams_append_name_value">#</a></span></h4>
<div class="signature"><ul>
<li><code>name</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>在查询字符串中附加一个新的键值对。</p>
<h4>urlSearchParams.delete(name)<span><a class="mark" href="#url_urlsearchparams_delete_name" id="url_urlsearchparams_delete_name">#</a></span></h4>
<div class="signature"><ul>
<li><code>name</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>删除所有键为<code>name</code>的键值对。</p>
<h4>urlSearchParams.entries()<span><a class="mark" href="#url_urlsearchparams_entries" id="url_urlsearchparams_entries">#</a></span></h4>
<div class="signature"><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;Iterator&gt;</a>
在查询中的每个键值对上返回一个ES6迭代器。 迭代器的每一项都是一个JavaScript数组。 Array的第一个项是键<code>name</code>，Array的第二个项是值<code>value</code>。</li>
</ul>
</div><p>别名为<a href="#url_urlsearchparams_iterator"><code>urlSearchParams[@@iterator]()</code></a>.</p>
<h4>urlSearchParams.forEach(fn[, thisArg])<span><a class="mark" href="#url_urlsearchparams_foreach_fn_thisarg" id="url_urlsearchparams_foreach_fn_thisarg">#</a></span></h4>
<div class="signature"><ul>
<li><code>fn</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> 在查询字符串中的每个键值对的调用函数。</li>
<li><code>thisArg</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a> 当<code>fn</code>调用时，被用作<code>this</code>值的对象</li>
</ul>
</div><p>在查询字符串中迭代每个键值对，并调用给定的函数。</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://example.org/?a=b&amp;c=d&apos;);
myURL.searchParams.forEach((value, name, searchParams) =&gt; {
  console.log(name, value, myURL.searchParams === searchParams);
});
  // 输出:
  // a b true
  // c d true
</code></pre>
<h4>urlSearchParams.get(name)<span><a class="mark" href="#url_urlsearchparams_get_name" id="url_urlsearchparams_get_name">#</a></span></h4>
<div class="signature"><ul>
<li><code>name</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;string&gt;</a> ，如果没有键值对对应给定的<code>name</code>则返回<code>null</code>。</li>
</ul>
</div><p>返回键是<code>name</code>的第一个键值对的值。如果没有对应的键值对，则返回<code>null</code>。</p>
<h4>urlSearchParams.getAll(name)<span><a class="mark" href="#url_urlsearchparams_getall_name" id="url_urlsearchparams_getall_name">#</a></span></h4>
<div class="signature"><ul>
<li><code>name</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;Array&gt;</a></li>
</ul>
</div><p>返回键是<code>name</code>的所有键值对的值，如果没有满足条件的键值对，则返回一个空的数组。</p>
<h4>urlSearchParams.has(name)<span><a class="mark" href="#url_urlsearchparams_has_name" id="url_urlsearchparams_has_name">#</a></span></h4>
<div class="signature"><ul>
<li><code>name</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a></li>
</ul>
</div><p>如果存在至少一对键是name的键值对则返回 <code>true</code>。</p>
<h4>urlSearchParams.keys()<span><a class="mark" href="#url_urlsearchparams_keys" id="url_urlsearchparams_keys">#</a></span></h4>
<div class="signature"><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;Iterator&gt;</a></li>
</ul>
</div><p>在每一个键值对上返回一个键的ES6迭代器。</p>
<pre><code class="lang-js">const { URLSearchParams } = require(&apos;url&apos;);
const params = new URLSearchParams(&apos;foo=bar&amp;foo=baz&apos;);
for (const name of params.keys()) {
  console.log(name);
}
  // 输出:
  // foo
  // foo
</code></pre>
<h4>urlSearchParams.set(name, value)<span><a class="mark" href="#url_urlsearchparams_set_name_value" id="url_urlsearchparams_set_name_value">#</a></span></h4>
<div class="signature"><ul>
<li><code>name</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>将<code>URLSearchParams</code>对象中与<code>name</code>相对应的值设置为<code>value</code>。如果已经存在键为<code>name</code>的键值对，将第一对的值设为<code>value</code>并且删除其他对。如果不存在，则将此键值对附加在查询字符串后。</p>
<pre><code class="lang-js">const { URLSearchParams } = require(&apos;url&apos;);

const params = new URLSearchParams();
params.append(&apos;foo&apos;, &apos;bar&apos;);
params.append(&apos;foo&apos;, &apos;baz&apos;);
params.append(&apos;abc&apos;, &apos;def&apos;);
console.log(params.toString());
  // 输出 foo=bar&amp;foo=baz&amp;abc=def

params.set(&apos;foo&apos;, &apos;def&apos;);
params.set(&apos;xyz&apos;, &apos;opq&apos;);
console.log(params.toString());
  // 输出 foo=def&amp;abc=def&amp;xyz=opq
</code></pre>
<h4>urlSearchParams.sort()<span><a class="mark" href="#url_urlsearchparams_sort" id="url_urlsearchparams_sort">#</a></span></h4>
<div class="api_metadata">
<span>新增于: v7.7.0</span>
</div><p>按现有名称就地排列所有的名称-值对。使用[稳定排序算法][]完成排序，因此保留具有相同名称的名称-值对之间的相对顺序。</p>
<p>特别地，该方法可以用来增加缓存命中。</p>
<pre><code class="lang-js">const { URLSearchParams } = require(&apos;url&apos;);
const params = new URLSearchParams(&apos;query[]=abc&amp;type=search&amp;query[]=123&apos;);
params.sort();
console.log(params.toString());
  // Prints query%5B%5D=abc&amp;query%5B%5D=123&amp;type=search
</code></pre>
<h4>urlSearchParams.toString()<span><a class="mark" href="#url_urlsearchparams_tostring" id="url_urlsearchparams_tostring">#</a></span></h4>
<div class="signature"><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
</div><p>返回查询参数序列化后的字符串，必要时存在百分号编码字符。</p>
<h4>urlSearchParams.values()<span><a class="mark" href="#url_urlsearchparams_values" id="url_urlsearchparams_values">#</a></span></h4>
<div class="signature"><ul>
<li>Returns: 
            <a href="javascript:;" class="type">&lt;Iterator&gt;</a></li>
</ul>
</div><p>在每一个键值对上返回一个值的ES6迭代器。</p>
<h4>urlSearchParams[@@iterator]()<span><a class="mark" href="#url_urlsearchparams_iterator" id="url_urlsearchparams_iterator">#</a></span></h4>
<div class="signature"><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;Iterator&gt;</a></li>
</ul>
</div><p>返回在查询字符串中每一个键值对的ES6迭代器。迭代器的每一个项都是一个JavaScript数组。数组中的第一个项是<code>name</code>，第二个项是<code>value</code>。</p>
<p>别名：<a href="#url_urlsearchparams_entries"><code>urlSearchParams.entries()</code></a>.</p>
<pre><code class="lang-js">const { URLSearchParams } = require(&apos;url&apos;);
const params = new URLSearchParams(&apos;foo=bar&amp;xyz=baz&apos;);
for (const [name, value] of params) {
  console.log(name, value);
}
  // 输出:
  // foo bar
  // xyz baz
</code></pre>
<h3>url.domainToASCII(domain)<span><a class="mark" href="#url_url_domaintoascii_domain" id="url_url_domaintoascii_domain">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v7.4.0</span>
</div><ul>
<li><code>domain</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回<a href="javascript:;">Punycode</a> ASCII序列化的<code>domain</code>. 如果<code>domain</code>是无效域名，将返回空字符串。</p>
<p>它执行的是<a href="#url_url_domaintounicode_domain"><code>url.domainToUnicode()</code></a>的逆运算。</p>
<pre><code class="lang-js">const url = require(&apos;url&apos;);
console.log(url.domainToASCII(&apos;español.com&apos;));
  // 输出 xn--espaol-zwa.com
console.log(url.domainToASCII(&apos;中文.com&apos;));
  // 输出 xn--fiq228c.com
console.log(url.domainToASCII(&apos;xn--iñvalid.com&apos;));
  // 输出空字符串
</code></pre>
<h3>url.domainToUnicode(domain)<span><a class="mark" href="#url_url_domaintounicode_domain" id="url_url_domaintounicode_domain">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v7.4.0</span>
</div><ul>
<li><code>domain</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回Unicode序列化的<code>domain</code>. 如果<code>domain</code>是无效域名，将返回空字符串。</p>
<p>它执行的是<a href="#url_url_domaintoascii_domain"><code>url.domainToASCII()</code></a>的逆运算。</p>
<pre><code class="lang-js">const url = require(&apos;url&apos;);
console.log(url.domainToUnicode(&apos;xn--espaol-zwa.com&apos;));
  // 输出 español.com
console.log(url.domainToUnicode(&apos;xn--fiq228c.com&apos;));
  // 输出 中文.com
console.log(url.domainToUnicode(&apos;xn--iñvalid.com&apos;));
  // 输出空字符串
</code></pre>
<h3>url.format(URL[, options])<span><a class="mark" href="#url_url_format_url_options" id="url_url_format_url_options">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v7.6.0</span>
</div><ul>
<li><code>URL</code> 
            <a href="#url_the_whatwg_url_api" class="type">&lt;URL&gt;</a> 一个<a href="#url_the_whatwg_url_api">WHATWG URL</a>对象</li>
<li><code>options</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a><ul>
<li><code>auth</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 如果序列化的URL字符串应该包含用户名和密码为<code>true</code>，否则为<code>false</code>。默认为<code>true</code>。</li>
<li><code>fragment</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 如果序列化的URL字符串应该包含分段为<code>true</code>，否则为<code>false</code>。默认为<code>true</code>。</li>
<li><code>search</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 如果序列化的URL字符串应该包含搜索查询为<code>true</code>，否则为<code>false</code>。默认为<code>true</code>。</li>
<li><code>unicode</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> <code>true</code> 如果出现在URL字符串主机元素里的Unicode字符应该被直接编码而不是使用Punycode编码为<code>true</code>，默认为<code>false</code>。</li>
</ul>
</li>
</ul>
<p>返回一个<a href="#url_the_whatwg_url_api">WHATWG URL</a>对象的可自定义序列化的URL字符串表达。</p>
<p>虽然URL对象的<code>toString()</code>方法和<code>href</code>属性都可以返回URL的序列化的字符串。然而，两者都不可以被自定义。而<code>url.format(URL[, options])</code>方法允许输出的基本自定义。</p>
<p>例如：</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://a:b@你好你好?abc#foo&apos;);

console.log(myURL.href);
  // 输出 https://a:b@xn--6qqa088eba/?abc#foo

console.log(myURL.toString());
  // 输出 https://a:b@xn--6qqa088eba/?abc#foo

console.log(url.format(myURL, { fragment: false, unicode: true, auth: false }));
  // 输出 &apos;https://你好你好/?abc&apos;
</code></pre>
<h2>Legacy URL API<span><a class="mark" href="#url_legacy_url_api" id="url_legacy_url_api">#</a></span></h2>
<h3>Legacy urlObject<span><a class="mark" href="#url_legacy_urlobject" id="url_legacy_urlobject">#</a></span></h3>
<p>遗留的urlObject (<code>require(&apos;url&apos;).Url</code>)由<code>url.parse()</code>函数创建并返回。</p>
<h4>urlObject.auth<span><a class="mark" href="#url_urlobject_auth" id="url_urlobject_auth">#</a></span></h4>
<p><code>auth</code> 属性是 URL 的用户名与密码部分。
该字符串跟在 <code>protocol</code> 和双斜杠（如果有）的后面，排在 <code>host</code> 部分的前面且被一个 ASCII 的 at 符号（<code>@</code>）分隔。
该字符的格式为 <code>{username}[:{password}]</code>，<code>[:{password}]</code> 部分是可选的。</p>
<p>例如：<code>&apos;user:pass&apos;</code></p>
<h4>urlObject.hash<span><a class="mark" href="#url_urlobject_hash" id="url_urlobject_hash">#</a></span></h4>
<p><code>hash</code> 属性包含 URL 的碎片部分，包括开头的 ASCII 哈希字符（<code>#</code>）。</p>
<p>例如：<code>&apos;#hash&apos;</code></p>
<h4>urlObject.host<span><a class="mark" href="#url_urlobject_host" id="url_urlobject_host">#</a></span></h4>
<p><code>host</code> 属性是 URL 的完整的小写的主机部分，包括 <code>port</code>（如果有）。</p>
<p>例如：<code>&apos;sub.host.com:8080&apos;</code></p>
<h4>urlObject.hostname<span><a class="mark" href="#url_urlobject_hostname" id="url_urlobject_hostname">#</a></span></h4>
<p><code>hostname</code> 属性是 <code>host</code> 组成部分排除 <code>port</code> 之后的小写的主机名部分。</p>
<p>例如：<code>&apos;sub.host.com&apos;</code></p>
<h4>urlObject.href<span><a class="mark" href="#url_urlobject_href" id="url_urlobject_href">#</a></span></h4>
<p><code>href</code> 属性是解析后的完整的 URL 字符串，<code>protocol</code> 和 <code>host</code> 都会被转换为小写的。</p>
<p>例如：<code>&apos;http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash&apos;</code></p>
<h4>urlObject.path<span><a class="mark" href="#url_urlobject_path" id="url_urlobject_path">#</a></span></h4>
<p><code>path</code> 属性是一个 <code>pathname</code> 与 <code>search</code> 组成部分的串接。</p>
<p>例如：<code>&apos;/p/a/t/h?query=string&apos;</code></p>
<p>不会对 <code>path</code> 执行解码。</p>
<h4>urlObject.pathname<span><a class="mark" href="#url_urlobject_pathname" id="url_urlobject_pathname">#</a></span></h4>
<p><code>pathname</code> 属性包含 URL 的整个路径部分。
它跟在 <code>host</code> （包括 <code>port</code>）后面，排在 <code>query</code> 或 <code>hash</code> 组成部分的前面且被 ASCII 问号（<code>?</code>）或哈希字符（<code>#</code>）分隔。</p>
<p>例如：<code>&apos;/p/a/t/h&apos;</code></p>
<p>不会对路径字符串执行解码。</p>
<h4>urlObject.port<span><a class="mark" href="#url_urlobject_port" id="url_urlobject_port">#</a></span></h4>
<p><code>port</code> 属性是 <code>host</code> 组成部分中的数值型的端口部分。</p>
<p>例如：<code>&apos;8080&apos;</code></p>
<h4>urlObject.protocol<span><a class="mark" href="#url_urlobject_protocol" id="url_urlobject_protocol">#</a></span></h4>
<p><code>protocol</code> 属性表明 URL 的小写的协议体制。</p>
<p>例如：<code>&apos;http:&apos;</code></p>
<h4>urlObject.query<span><a class="mark" href="#url_urlobject_query" id="url_urlobject_query">#</a></span></h4>
<p><code>query</code> 属性是不含开头 ASCII 问号（<code>?</code>）的查询字符串，或一个被 <a href="querystring.html"><code>querystring</code></a> 模块的 <code>parse()</code> 方法返回的对象。
<code>query</code> 属性是一个字符串还是一个对象是由传入 <code>url.parse()</code> 的 <code>parseQueryString</code> 参数决定的。</p>
<p>例如：<code>&apos;query=string&apos;</code> or <code>{&apos;query&apos;: &apos;string&apos;}</code></p>
<p>如果返回一个字符串，则不会对查询字符串执行解码。
如果返回一个对象，则键和值都会被解码。</p>
<h4>urlObject.search<span><a class="mark" href="#url_urlobject_search" id="url_urlobject_search">#</a></span></h4>
<p><code>search</code> 属性包含 URL 的整个查询字符串部分，包括开头的 ASCII 问号字符（<code>?</code>）。</p>
<p>例如：<code>&apos;?query=string&apos;</code></p>
<p>不会对查询字符串执行解码。</p>
<h4>urlObject.slashes<span><a class="mark" href="#url_urlobject_slashes" id="url_urlobject_slashes">#</a></span></h4>
<p><code>slashes</code> 属性是一个 <code>boolean</code>，如果 <code>protocol</code> 中的冒号后面跟着两个 ASCII 斜杠字符（<code>/</code>），则值为 <code>true</code>。</p>
<h3>url.format(urlObject)<span><a class="mark" href="#url_url_format_urlobject" id="url_url_format_urlobject">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v7.0.0</td>
<td><p>URLs with a <code>file:</code> scheme will now always use the correct number of slashes regardless of <code>slashes</code> option. A false-y <code>slashes</code> option with no protocol is now also respected at all times.</p>
</td></tr>
<tr><td>v0.1.25</td>
<td><p><span>新增于: v0.1.25</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>urlObject</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a> | 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 一个 URL 对象（就像 <code>url.parse()</code> 返回的）。
如果是一个字符串，则通过 <code>url.parse()</code> 转换为一个对象。</li>
</ul>
<p><code>url.format()</code> 方法返回一个从 <code>urlObject</code> 格式化后的 URL 字符串。</p>
<p>如果 <code>urlObject</code> 不是一个对象或字符串，则 <code>url.format()</code> 抛出 <a href="errors.html#errors_class_typeerror"><code>TypeError</code></a>。</p>
<p>格式化过程如下：</p>
<ul>
<li>创建一个新的空字符串 <code>result</code>。</li>
<li>如果 <code>urlObject.protocol</code> 是一个字符串，则它会被原样添加到 <code>result</code>。</li>
<li>否则，如果 <code>urlObject.protocol</code> 不是 <code>undefined</code> 也不是一个字符串，则抛出 <a href="errors.html#errors_class_error"><code>Error</code></a>。</li>
<li>对于不是以 <code>:</code> 结束的 <code>urlObject.protocol</code>，<code>:</code> 会被添加到 <code>result</code>。</li>
<li>如果以下条件之一为真，则 <code>//</code> 会被添加到 <code>result</code>：<ul>
<li><code>urlObject.slashes</code> 属性为真；</li>
<li><code>urlObject.protocol</code> 以 <code>http</code>、<code>https</code>、<code>ftp</code>、<code>gopher</code> 或 <code>file</code> 开头；</li>
</ul>
</li>
<li>如果 <code>urlObject.auth</code> 属性的值为真，且 <code>urlObject.host</code> 或 <code>urlObject.hostname</code> 不为 <code>undefined</code>，则 <code>urlObject.auth</code> 会被添加到 <code>result</code>，且后面带上 <code>@</code>。</li>
<li>如果 <code>urlObject.host</code> 属性为 <code>undefined</code>，则：<ul>
<li>如果 <code>urlObject.hostname</code> 是一个字符串，则它会被添加到 <code>result</code>。</li>
<li>否则，如果 <code>urlObject.hostname</code> 不是 <code>undefined</code> 也不是一个字符串，则抛出 <a href="errors.html#errors_class_error"><code>Error</code></a>。</li>
<li>如果 <code>urlObject.port</code> 属性的值为真，且 <code>urlObject.hostname</code> 不为 <code>undefined</code>：<ul>
<li><code>:</code> 会被添加到 <code>result</code>。</li>
<li><code>urlObject.port</code> 的值会被添加到 <code>result</code>。</li>
</ul>
</li>
</ul>
</li>
<li>否则，如果 <code>urlObject.host</code> 属性的值为真，则 <code>urlObject.host</code> 的值会被添加到 <code>result</code>。</li>
<li>如果 <code>urlObject.pathname</code> 属性是一个字符串且不是一个空字符串：<ul>
<li>如果 <code>urlObject.pathname</code> 不是以 <code>/</code> 开头，则 <code>/</code> 会被添加到 <code>result</code>。</li>
<li><code>urlObject.pathname</code> 的值会被添加到 <code>result</code>。</li>
</ul>
</li>
<li>否则，如果 <code>urlObject.pathname</code> 不是 <code>undefined</code> 也不是一个字符串，则抛出 <a href="errors.html#errors_class_error"><code>Error</code></a>。</li>
<li>如果 <code>urlObject.search</code> 属性为 <code>undefined</code> 且 <code>urlObject.query</code> 属性是一个 <code>Object</code>，则 <code>?</code> 会被添加到 <code>result</code>，后面跟上把 <code>urlObject.query</code> 的值传入 <a href="querystring.html"><code>querystring</code></a> 模块的 <code>stringify()</code> 方法的调用结果。</li>
<li>否则，如果 <code>urlObject.search</code> 是一个字符串：<ul>
<li>如果 <code>urlObject.search</code> 的值不是以 <code>?</code> 开头，则 <code>?</code> 会被添加到 <code>result</code>。</li>
<li><code>urlObject.search</code> 的值会被添加到 <code>result</code>。</li>
</ul>
</li>
<li>否则，如果 <code>urlObject.search</code> 不是 <code>undefined</code> 也不是一个字符串，则抛出 <a href="errors.html#errors_class_error"><code>Error</code></a>。</li>
<li>如果 <code>urlObject.hash</code> 属性是一个字符串：<ul>
<li>如果 <code>urlObject.hash</code> 的值不是以 <code>#</code> 开头，则 <code>#</code> 会被添加到 <code>result</code>。</li>
<li><code>urlObject.hash</code> 的值会被添加到 <code>result</code>。</li>
</ul>
</li>
<li>否则，如果 <code>urlObject.hash</code> 属性不是 <code>undefined</code> 也不是一个字符串，则抛出 <a href="errors.html#errors_class_error"><code>Error</code></a>。</li>
<li>返回 <code>result</code>。</li>
</ul>
<h3>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])<span><a class="mark" href="#url_url_parse_urlstring_parsequerystring_slashesdenotehost" id="url_url_parse_urlstring_parsequerystring_slashesdenotehost">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.25</span>
</div><ul>
<li><code>urlString</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 要解析的 URL 字符串。</li>
<li><code>parseQueryString</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code>，则 <code>query</code> 属性总会通过 <a href="querystring.html"><code>querystring</code></a> 模块的 <code>parse()</code> 方法生成一个对象。
如果为 <code>false</code>，则返回的 URL 对象上的 <code>query</code> 属性会是一个未解析、未解码的字符串。
默认为 <code>false</code>。</li>
<li><code>slashesDenoteHost</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code>，则 <code>//</code> 之后至下一个 <code>/</code> 之前的字符串会被解析作为 <code>host</code>。
例如，<code>//foo/bar</code> 会被解析为 <code>{host: &apos;foo&apos;, pathname: &apos;/bar&apos;}</code> 而不是 <code>{pathname: &apos;//foo/bar&apos;}</code>。
默认为 <code>false</code>。</li>
</ul>
<p><code>url.parse()</code> 方法会解析一个 URL 字符串并返回一个 URL 对象。</p>
<p>如果<code>urlString</code>不是字符串将会抛出<code>TypeError</code>。</p>
<p>如果<code>auth</code>属性存在但无法编码则抛出<code>URIError</code>。</p>
<h3>url.resolve(from, to)<span><a class="mark" href="#url_url_resolve_from_to" id="url_url_resolve_from_to">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.6.0</td>
<td><p>The <code>auth</code> fields are now kept intact when <code>from</code> and <code>to</code> refer to the same host.</p>
</td></tr>
<tr><td>v6.5.0, v4.6.2</td>
<td><p>The <code>port</code> field is copied correctly now.</p>
</td></tr>
<tr><td>v6.0.0</td>
<td><p>The <code>auth</code> fields is cleared now the <code>to</code> parameter contains a hostname.</p>
</td></tr>
<tr><td>v0.1.25</td>
<td><p><span>新增于: v0.1.25</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>from</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 解析时相对的基本 URL。</li>
<li><code>to</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 要解析的超链接 URL。</li>
</ul>
<p><code>url.resolve()</code> 方法会以一种 Web 浏览器解析超链接的方式把一个目标 URL 解析成相对于一个基础 URL。</p>
<p>例子：</p>
<pre><code class="lang-js">const url = require(&apos;url&apos;);
url.resolve(&apos;/one/two/three&apos;, &apos;four&apos;);         // &apos;/one/two/four&apos;
url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;);    // &apos;http://example.com/one&apos;
url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;); // &apos;http://example.com/two&apos;
</code></pre>
<p><a id="whatwg-percent-encoding"></a></p>
<h2>Percent-Encoding in URLs<span><a class="mark" href="#url_percent_encoding_in_urls" id="url_percent_encoding_in_urls">#</a></span></h2>
<p>允许URL只包含一定范围的字符。 任何超出该范围的字符都必须进行编码。 如何对这些字符进行编码，以及哪些字符要编码完全取决于字符在URL结构内的位置。</p>
<h3>Legacy API<span><a class="mark" href="#url_legacy_api" id="url_legacy_api">#</a></span></h3>
<p>在遗留的API中，空格(<code>&apos; &apos;</code>)及以下字符将自动转义为URL对象的属性：</p>
<pre><code class="lang-txt">&lt; &gt; &quot; ` \r \n \t { } | \ ^ &apos;
</code></pre>
<p>例如，ASCII空格字符(<code>&apos; &apos;</code>)被编码为<code>%20</code>.ASCII斜杠(<code>/</code>)字符被编码为<code>%3C</code>。</p>
<h3>WHATWG API<span><a class="mark" href="#url_whatwg_api" id="url_whatwg_api">#</a></span></h3>
<p><a href="javascript:;">WHATWG URL Standard</a>使用比遗留的API更具选择性和更精细的方法来选择使用的编码字符。</p>
<p>WHATWG算法定义了三个“百分比编码集”，它们描述了必须进行百分编码的字符范围：</p>
<ul>
<li><p><em>C0 control percent-encode set(C0控制百分比编码集)</em> 包括范围在U+0000 ~ U+001F（含）的代码点及大于U+007E的所有代码点。</p>
</li>
<li><p><em>path percent-encode set(路径百分比编码集)</em> 包括 <em>C0 control percent-encode set(C0控制百分比编码集)</em> 的代码点 及 U+0020, U+0022, U+0023, U+003C, U+003E, U+003F, U+0060, U+007B, 和 U+007D 的代码点。</p>
</li>
<li><p><em>userinfo encode set(用户信息编码集)</em> 包括 <em>path percent-encode set(路径百分比编码集)</em> 的代码点 及 U+002F, U+003A, U+003B, U+003D, U+0040, U+005B, U+005C, U+005D, U+005E, 和 U+007C 的代码点。</p>
</li>
</ul>
<p><em>userinfo percent-encode set(用户信息百分比编码集)</em> 专门用于用户名和密码部分的编码。<em>path percent-encode set(路径百分比编码集)</em> 用于大多数URL的路径部分编码。<em>C0 control percent-encode set(C0控制百分比编码集)</em> 则用于所有其他情况的编码，特别地包括URL的分段部分，特殊条件下也包括主机及路径部分。</p>
<p>当主机名中出现非ASCII字符时，主机名将使用<a href="javascript:;">Punycode</a>算法进行编码。然而，请注意，主机名<em>可能同时</em> 包含Punycode编码和百分比编码的字符。例如：</p>
<pre><code class="lang-js">const { URL } = require(&apos;url&apos;);
const myURL = new URL(&apos;https://%CF%80.com/foo&apos;);
console.log(myURL.href);
  // 输出 https://xn--1xa.com/foo
console.log(myURL.origin);
  // 输出 https://π.com
</code></pre>

      </div>
    </div>

    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="index.html" title="Go back to the home page">
          Node.js 中文文档 | Node.js 中文网
        </a>
      </div>
      
        <!-- [start-include:_toc.md] -->
<ul>
<li><a href="documentation.html">关于本文档</a></li>
<li><a href="synopsis.html">用法与例子</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a href="assert.html">断言测试</a></li>
<li><a href="async_hooks.html">异步钩子（Async Hooks）</a></li>
<li><a href="buffer.html">缓存（Buffer）</a></li>
<li><a href="addons.html">C++ 插件</a></li>
<li><a href="n-api.html">C/C++ 插件 - N-API</a></li>
<li><a href="child_process.html">子进程</a></li>
<li><a href="cluster.html">集群（Cluster）</a></li>
<li><a href="cli.html">命令行参数</a></li>
<li><a href="console.html">控制台（Console）</a></li>
<li><a href="crypto.html">加密（Crypto）</a></li>
<li><a href="debugger.html">调试器</a></li>
<li><a href="deprecations.html">废弃的 API</a></li>
<li><a href="dns.html">DNS</a></li>
<li><a href="domain.html">域（Domain）</a></li>
<li><a href="esm.html">ECMAScript 模块</a></li>
<li><a href="errors.html">错误（Errors）</a></li>
<li><a href="events.html">事件（Events）</a></li>
<li><a href="fs.html">文件系统</a></li>
<li><a href="globals.html">全局对象（Globals）</a></li>
<li><a href="http.html">HTTP</a></li>
<li><a href="http2.html">HTTP/2</a></li>
<li><a href="https.html">HTTPS</a></li>
<li><a href="inspector.html">检查工具（Inspector）</a></li>
<li><a href="intl.html">国际化</a></li>
<li><a href="modules.html">模块（Modules）</a></li>
<li><a href="net.html">网络（Net）</a></li>
<li><a href="os.html">操作系统（OS）</a></li>
<li><a href="path.html">路径（Path）</a></li>
<li><a href="perf_hooks.html">性能钩子（Performance Hooks）</a></li>
<li><a href="process.html">进程</a></li>
<li><a href="punycode.html">Punycode</a></li>
<li><a href="querystring.html">查询字符串</a></li>
<li><a href="readline.html">逐行读取</a></li>
<li><a href="repl.html">交互式解释器（REPL）</a></li>
<li><a href="stream.html">流（Stream）</a></li>
<li><a href="string_decoder.html">字符串解码</a></li>
<li><a href="timers.html">定时器（Timers）</a></li>
<li><a href="tls.html">安全传输层（TLS/SSL）</a></li>
<li><a href="tracing.html">事件跟踪（Tracing）</a></li>
<li><a href="tty.html">TTY</a></li>
<li><a href="dgram.html">UDP / 数据报</a></li>
<li><a href="">URL</a></li>
<li><a href="util.html">工具集</a></li>
<li><a href="v8.html">V8</a></li>
<li><a href="vm.html">虚拟机（VM）</a></li>
<li><a href="zlib.html">压缩（ZLIB）</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a href="javascript:;">GitHub 仓库和问题跟踪</a></li>
<li><a href="javascript:;">邮件列表</a></li>
</ul>
<!-- [end-include:_toc.md] -->

      
    </div>
  </div>
  <script src="static/js/sh_main.js"></script>
  <script src="static/js/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>
