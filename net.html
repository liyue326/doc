<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>网络（Net） | Node.js 中文文档 | Node.js 中文网</title>
  <meta name="description" content="Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。">
  <link rel="stylesheet" href="static/css/style.css">
  <link rel="stylesheet" href="static/css/sh.css">
  
  <link rel="apple-touch-icon" href="static/picture/apple-touch-icon.png">
  
  
  

</head>
<body class="alt apidoc" id="api-section-net">
  <div id="content" class="clearfix">
    <div id="column1" data-id="net" class="interior">
      <header>
        <h1>Node.js v8.x 中文文档</h1>
        <hr>
      </header>

      <div id="toc">
        <h2>目录</h2>
        <ul>
<li><span class="stability_2"><a href="#net_net">net (网络)</a></span><ul>
<li><span class="stability_undefined"><a href="#net_ipc_support">IPC Support</a></span><ul>
<li><span class="stability_undefined"><a href="#net_identifying_paths_for_ipc_connections">Identifying paths for IPC connections</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#net_class_net_server">net.Server 类</a></span><ul>
<li><span class="stability_undefined"><a href="#net_new_net_server_options_connectionlistener">new net.Server([options][, connectionListener])</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_close">&apos;close&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_connection">&apos;connection&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_error">&apos;error&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_listening">&apos;listening&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_address">server.address()</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_close_callback">server.close([callback])</a></span></li>
<li><span class="stability_0"><a href="#net_server_connections">server.connections</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_getconnections_callback">server.getConnections(callback)</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_listen">server.listen()</a></span><ul>
<li><span class="stability_undefined"><a href="#net_server_listen_handle_backlog_callback">server.listen(handle[, backlog][, callback])</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_listen_options_callback">server.listen(options[, callback])</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_listen_path_backlog_callback">server.listen(path[, backlog][, callback])</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_listen_port_host_backlog_callback">server.listen([port][, host][, backlog][, callback])</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#net_server_listening">server.listening</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_maxconnections">server.maxConnections</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_ref">server.ref()</a></span></li>
<li><span class="stability_undefined"><a href="#net_server_unref">server.unref()</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#net_class_net_socket">net.Socket 类</a></span><ul>
<li><span class="stability_undefined"><a href="#net_new_net_socket_options">new net.Socket([options])</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_close_1">&apos;close&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_connect">&apos;connect&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_data">&apos;data&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_drain">&apos;drain&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_end">&apos;end&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_error_1">&apos;error&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_lookup">&apos;lookup&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_event_timeout">&apos;timeout&apos; 事件</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_address">socket.address()</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_buffersize">socket.bufferSize</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_bytesread">socket.bytesRead</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_byteswritten">socket.bytesWritten</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_connect">socket.connect()</a></span><ul>
<li><span class="stability_undefined"><a href="#net_socket_connect_options_connectlistener">socket.connect(options[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_connect_path_connectlistener">socket.connect(path[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_connect_port_host_connectlistener">socket.connect(port[, host][, connectListener])</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#net_socket_connecting">socket.connecting</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_destroy_exception">socket.destroy([exception])</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_destroyed">socket.destroyed</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_end_data_encoding">socket.end([data][, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_localaddress">socket.localAddress</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_localport">socket.localPort</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_pause">socket.pause()</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_ref">socket.ref()</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_remoteaddress">socket.remoteAddress</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_remotefamily">socket.remoteFamily</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_remoteport">socket.remotePort</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_resume">socket.resume()</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_setencoding_encoding">socket.setEncoding([encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_setkeepalive_enable_initialdelay">socket.setKeepAlive([enable][, initialDelay])</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_setnodelay_nodelay">socket.setNoDelay([noDelay])</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_settimeout_timeout_callback">socket.setTimeout(timeout[, callback])</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_unref">socket.unref()</a></span></li>
<li><span class="stability_undefined"><a href="#net_socket_write_data_encoding_callback">socket.write(data[, encoding][, callback])</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#net_net_connect">net.connect()</a></span><ul>
<li><span class="stability_undefined"><a href="#net_net_connect_options_connectlistener">net.connect(options[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="#net_net_connect_path_connectlistener">net.connect(path[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="#net_net_connect_port_host_connectlistener">net.connect(port[, host][, connectListener])</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#net_net_createconnection">net.createConnection()</a></span><ul>
<li><span class="stability_undefined"><a href="#net_net_createconnection_options_connectlistener">net.createConnection(options[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="#net_net_createconnection_path_connectlistener">net.createConnection(path[, connectListener])</a></span></li>
<li><span class="stability_undefined"><a href="#net_net_createconnection_port_host_connectlistener">net.createConnection(port[, host][, connectListener])</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#net_net_createserver_options_connectionlistener">net.createServer([options][, connectionListener])</a></span></li>
<li><span class="stability_undefined"><a href="#net_net_isip_input">net.isIP(input)</a></span></li>
<li><span class="stability_undefined"><a href="#net_net_isipv4_input">net.isIPv4(input)</a></span></li>
<li><span class="stability_undefined"><a href="#net_net_isipv6_input">net.isIPv6(input)</a></span></li>
</ul>
</li>
</ul>

      </div>
<div id="apicontent">
        <h1>net (网络)<span><a class="mark" href="#net_net" id="net_net">#</a></span></h1>
<!--introduced_in=v0.10.0-->
<div class="api_stability api_stability_2"><a href="documentation.html#documentation_stability_index">稳定性: 2</a> - 稳定</div><p><code>net</code> 模块提供了创建基于流的 TCP 或 [IPC][] 服务器([<code>net.createServer()</code>][])和客户端([<code>net.createConnection()</code>][]) 的异步网络 API。</p>
<p>通过以下方式引入:</p>
<pre><code class="lang-js">const net = require(&apos;net&apos;);
</code></pre>
<h2>IPC Support<span><a class="mark" href="#net_ipc_support" id="net_ipc_support">#</a></span></h2>
<p><code>net</code> 模块在 Windows 上支持命名管道 IPC，在其他操作系统上支持 UNIX 域套接字。</p>
<h3>Identifying paths for IPC connections<span><a class="mark" href="#net_identifying_paths_for_ipc_connections" id="net_identifying_paths_for_ipc_connections">#</a></span></h3>
<p>[<code>net.connect()</code>][], [<code>net.createConnection()</code>][], [<code>server.listen()</code>][] 和
[<code>socket.connect()</code>][] 使用一个 <code>path</code> 参数来识别 IPC 端点。</p>
<p>在 UNIX 上，本地域也称为 UNIX 域。参数 <code>path</code> 是文件系统路径名。它被从 <code>sizeof(sockaddr_un.sun_path) - 1</code> 处被截断，其长度因操作系统不同而在 91 至 107 字节之间变化。典型值在 Linux 上为 107，在 macOS 上为 103。该路径受到与创建文件相同的命名约定和权限检查。它将在文件系统中可见，并且将持续到取消链接的时候。</p>
<p>在 Windows 上，本地域通过命名管道实现。路径必须是以 <code>\\?\pipe\</code> 或 <code>\\.\pipe\</code> 为入口。路径允许任何字符，但后面的字符可能会对管道名称进行一些处理，例如解析 <code>..</code> 序列。尽管如此，管道空间是平面的。管道不会持续，当最后一次引用关闭时，管道就会被删除。不要忘了 JavaScript 字符串转义需要使用双反斜杠指定路径，例如：</p>
<pre><code class="lang-js">net.createServer().listen(
  path.join(&apos;\\\\?\\pipe&apos;, process.cwd(), &apos;myctl&apos;));
</code></pre>
<h2>net.Server 类<span><a class="mark" href="#net_class_net_server" id="net_class_net_server">#</a></span></h2>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>这个类用于创建 TCP 或 [IPC][] server。</p>
<h3>new net.Server([options][, connectionListener])<span><a class="mark" href="#net_new_net_server_options_connectionlistener" id="net_new_net_server_options_connectionlistener">#</a></span></h3>
<div class="signature"><ul>
<li>返回: <span class="type">&lt;net.Server&gt;</span></li>
</ul>
</div><p>查看 [<code>net.createServer([options][, connectionListener])</code>][<code>net.createServer()</code>].</p>
<p><code>net.Server</code> is an [<code>EventEmitter</code>][]实现了以下事件:</p>
<h3>&apos;close&apos; 事件<span><a class="mark" href="#net_event_close" id="net_event_close">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div><p>当server关闭的时候触发. 注意,如果有连接存在, 直到所有的连接结束才会触发这个事件</p>
<h3>&apos;connection&apos; 事件<span><a class="mark" href="#net_event_connection" id="net_event_connection">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a>  connection 对象</li>
</ul>
<p>当一个新的connection建立的时候触发. <code>socket</code> 是一个
<code>net.Socket</code>的实例对象.</p>
<h3>&apos;error&apos; 事件<span><a class="mark" href="#net_event_error" id="net_event_error">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>
            <a href="javascript:;" class="type">&lt;Error&gt;</a></li>
</ul>
<p>当错误出现的时候触发. 不同与 [<code>net.Socket</code>][], [<code>&apos;close&apos;</code>][]
事件不会在这个事件触发后继续触发 除非
[<code>server.close()</code>][] 是手动调用. 在
[<code>server.listen()</code>][]中的例子.</p>
<h3>&apos;listening&apos; 事件<span><a class="mark" href="#net_event_listening" id="net_event_listening">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当服务被绑定后调用 [<code>server.listen()</code>][].</p>
<h3>server.address()<span><a class="mark" href="#net_server_address" id="net_server_address">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>如果在IP socket上监听,则返回绑定的ip地址, 地址族和操作系统报告的服务端口
在找到操作系统分配的地址时，找到指定的端口是有用的.返回一个有 <code>port</code>, <code>family</code>, 和 <code>address</code> 属性:
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>的对象</p>
<p>对于在管道或UNIX域套接字上侦听的server,该名称将返回为字符串</p>
<p>例子:</p>
<pre><code class="lang-js">const server = net.createServer((socket) =&gt; {
  socket.end(&apos;goodbye\n&apos;);
}).on(&apos;error&apos;, (err) =&gt; {
  // handle errors here
  throw err;
});

// grab an arbitrary unused port.
server.listen(() =&gt; {
  console.log(&apos;opened server on&apos;, server.address());
});
</code></pre>
<p>只有到了 <code>&apos;listening&apos;</code> 事件被触发时候.才可以调用 <code>server.address()</code> </p>
<h3>server.close([callback])<span><a class="mark" href="#net_server_close_callback" id="net_server_close_callback">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>返回: <span class="type">&lt;net.Server&gt;</span></li>
</ul>
<p>停止 server接受建立新的connections并保持已经存在的connections.此功能是异步的,当所有的connections关闭同时server响应 [<code>&apos;close&apos;</code>][]事件的时候,server将会最终关闭.
一旦<code>&apos;close&apos;</code>发生将会调用可选的回调函数. 与该事件不同, 如果服务器在关闭时未打开，则将使用错误作为唯一参数。</p>
<p>返回 <code>server</code>。</p>
<h3>server.connections<span><a class="mark" href="#net_server_connections" id="net_server_connections">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.2.0</span><span>废弃于: v0.9.7</span>
</div><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 废弃的: 使用 [<code>server.getConnections()</code>][] 来替代。</div><p>服务器上并发的连接数。</p>
<p>当发送一个 <code>socket</code> 给用<code>child_process.fork()</code> 创建的子进程时，这会返回 <code>null</code> 。要轮询分叉（forks）获得活动连接数可以使用异步的<code>server.getConnections()</code>来替代。</p>
<h3>server.getConnections(callback)<span><a class="mark" href="#net_server_getconnections_callback" id="net_server_getconnections_callback">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.9.7</span>
</div><ul>
<li>Returns <span class="type">&lt;net.Server&gt;</span></li>
</ul>
<p>异步获取服务器的当前并发连接数。当 socket 被传递给子进程时工作。</p>
<p>回调函数的两个参数是 err 和 count。</p>
<h3>server.listen()<span><a class="mark" href="#net_server_listen" id="net_server_listen">#</a></span></h3>
<p>为 connections 启动一个 server 监听. 一个 <code>net.Server</code> 可以是一个 TCP 或者 
一个 [IPC][] server，这取决于它监听什么。</p>
<p>可能的参数:</p>
<ul>
<li>[<code>server.listen(handle[, backlog][, callback])</code>][<code>server.listen(handle)</code>]</li>
<li>[<code>server.listen(options[, callback])</code>][<code>server.listen(options)</code>]</li>
<li>[<code>server.listen(path[, backlog][, callback])</code>][<code>server.listen(path)</code>]
for [IPC][] servers</li>
<li>[<code>server.listen([port][, host][, backlog][, callback])</code>][<code>server.listen(port, host)</code>]
for TCP servers</li>
</ul>
<p>这个函数是异步的。当 server 开始监听，[<code>&apos;listening&apos;</code>][] 事件会触发。最后一个参数
<code>callback</code> 将会被添加为[<code>&apos;listening&apos;</code>][] 事件的监听器。</p>
<p>所有的 <code>listen()</code> 方法可以传入一个 <code>backlog</code> 参数来指定待连接队列的最大长度。
实际长度将通过 OS 的 sysctl 设置， 例如 linux 里的 <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code>。
这个参数的默认值是511 (不是512）</p>
<p><em>说明</em>：</p>
<ul>
<li><p>所有的 [<code>net.Socket</code>][] 都被设置为 <code>SO_REUSEADDR</code> (详见 [socket(7)][])</p>
</li>
<li><p><code>server.listen()</code> 方法可能会被调用多次。每个后续的调用都将使用其提供的选项重新打开服务器。</p>
</li>
</ul>
<p>监听时，其中一个最常见的错误是 <code>EADDRINUSE</code>。这是因为另一个 server 已经监听了该请求中的 <code>port</code> / <code>path</code> / <code>handle</code>。
处理这种情况的一种方法是在一定时间后重试：</p>
<pre><code class="lang-js">server.on(&apos;error&apos;, (e) =&gt; {
  if (e.code === &apos;EADDRINUSE&apos;) {
    console.log(&apos;Address in use, retrying...&apos;);
    setTimeout(() =&gt; {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});
</code></pre>
<h4>server.listen(handle[, backlog][, callback])<span><a class="mark" href="#net_server_listen_handle_backlog_callback" id="net_server_listen_handle_backlog_callback">#</a></span></h4>
<div class="api_metadata">
<span>新增于: v0.5.10</span>
</div><ul>
<li><code>handle</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a></li>
<li><code>backlog</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> [<code>server.listen()</code>][] 的通用参数</li>
<li><code>callback</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> [<code>server.listen()</code>][] 的通用参数</li>
<li>Returns: <span class="type">&lt;net.Server&gt;</span></li>
</ul>
<p>启动一个服务器，监听已经绑定到端口、UNIX 域套接字或 Windows 命名管道的给定句柄上的连接。</p>
<p>句柄对象可以是服务器、套接字（任何具有底层 <code>_handle</code> 成员的东西），也可以是具有 <code>fd</code> 成员的对象，该成员是一个有效的文件描述符。</p>
<p><em>注意</em>：在Windows上不支持在文件描述符上进行监听。</p>
<h4>server.listen(options[, callback])<span><a class="mark" href="#net_server_listen_options_callback" id="net_server_listen_options_callback">#</a></span></h4>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div><ul>
<li><code>options</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a> 必须。支持以下参数属性：<ul>
<li><code>port</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a></li>
<li><code>host</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
<li><code>path</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 如果指定了 <code>port</code> 参数则会被忽略。查看 [Identifying paths for IPC connections][]。</li>
<li><code>backlog</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> [<code>server.listen()</code>][] 的通用参数。</li>
<li><code>exclusive</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 默认 <code>false</code>。</li>
</ul>
</li>
<li><code>callback</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> [<code>server.listen()</code>][] 的通用参数。</li>
<li>Returns: <span class="type">&lt;net.Server&gt;</span></li>
</ul>
<p>如果指定了 <code>port</code> 参数，该方法的行为跟 [<code>server.listen([port][, hostname][, backlog][, callback])</code>][<code>server.listen(port, host)</code>] 一样。否则，如果指定了 <code>path</code> 参数，该方法的行为与 [<code>server.listen(path[, backlog][, callback])</code>][<code>server.listen(path)</code>] 一致。如果没有 <code>port</code> 或者 <code>path</code> 参数，则会抛出一个错误。</p>
<p>如果 <code>exclusive</code> 是 <code>false</code>（默认），则集群的所有进程将使用相同的底层句柄，允许共享连接处理任务。如果 <code>exclusive</code> 是 <code>true</code>，则句柄不会被共享，如果尝试端口共享将导致错误。监听独立端口的例子如下。</p>
<pre><code class="lang-js">server.listen({
  host: &apos;localhost&apos;,
  port: 80,
  exclusive: true
});
</code></pre>
<h4>server.listen(path[, backlog][, callback])<span><a class="mark" href="#net_server_listen_path_backlog_callback" id="net_server_listen_path_backlog_callback">#</a></span></h4>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>path</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 服务器需要监听的路径。查看 [Identifying paths for IPC connections][]。</li>
<li><code>backlog</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> [<code>server.listen()</code>][] 通用参数。</li>
<li><code>callback</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> [<code>server.listen()</code>][] 通用参数。</li>
<li>Returns: <span class="type">&lt;net.Server&gt;</span></li>
</ul>
<p>启动一个 [IPC][] 服务器监听给定 <code>path</code> 的连接。</p>
<h4>server.listen([port][, host][, backlog][, callback])<span><a class="mark" href="#net_server_listen_port_host_backlog_callback" id="net_server_listen_port_host_backlog_callback">#</a></span></h4>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>port</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a></li>
<li><code>host</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
<li><code>backlog</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> [<code>server.listen()</code>][] 函数的通用参数</li>
<li><code>callback</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> [<code>server.listen()</code>][] 函数的通用参数</li>
<li>Returns: <span class="type">&lt;net.Server&gt;</span></li>
</ul>
<p>启动一个TCP服务监听输入的<code>port</code>和<code>host</code>。</p>
<p>如果<code>port</code>省略或是0，系统会随意分配一个在[<code>&apos;listening&apos;</code>][]事件触发后能被<code>server.address().port</code>检索的无用端口。</p>
<p>如果<code>host</code>省略，如果IPv6可用，服务器将会接收基于[unspecified IPv6 address][] (<code>::</code>)的连接，否则接收基于[unspecified IPv4 address][] (<code>0.0.0.0</code>)的连接</p>
<p><em>注意</em>: 在大多数的系统, 监听[unspecified IPv6 address][] (<code>::</code>)可能导致<code>net.Server</code>也监听[unspecified IPv4 address][] (<code>0.0.0.0</code>).</p>
<h3>server.listening<span><a class="mark" href="#net_server_listening" id="net_server_listening">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.7.0</span>
</div><p>一个布尔值， 表明 server 是否正在监听连接</p>
<h3>server.maxConnections<span><a class="mark" href="#net_server_maxconnections" id="net_server_maxconnections">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.2.0</span>
</div><p>设置该属性使得当 server 连接数过多时拒绝连接。</p>
<p>一旦将一个 socket 发送给 [<code>child_process.fork()</code>][] 生成的子进程，就不推荐使用该选项。</p>
<h3>server.ref()<span><a class="mark" href="#net_server_ref" id="net_server_ref">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div><ul>
<li>Returns: <span class="type">&lt;net.Server&gt;</span></li>
</ul>
<p>与 <code>unref</code> 相反，在一个已经调用 <code>unref</code> 的 server 中调用 <code>ref</code>，如果 server 是仅存的 server，则程序不会退出（默认）。对一个已经调用 <code>ref</code> 的 server 再次调用 <code>ref</code> 将不会再有效果。</p>
<h3>server.unref()<span><a class="mark" href="#net_server_unref" id="net_server_unref">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div><ul>
<li>Returns: <span class="type">&lt;net.Server&gt;</span></li>
</ul>
<p>如果这个server在事件系统中是唯一有效的，那么对server调用<code>unref</code>将允许程序退出。如果这个server已经调用过<code>unref</code>那么再次调用将不会再有效果。</p>
<h2>net.Socket 类<span><a class="mark" href="#net_class_net_socket" id="net_class_net_socket">#</a></span></h2>
<div class="api_metadata">
<span>新增于: v0.3.4</span>
</div><p>这个类是 TCP 或 UNIX Socket 的抽象（在Windows上使用命名管道，而UNIX使用域套接字）。一个<code>net.Socket</code>也是一个[duplex stream][]，所以它能被读或写，并且它也是一个[<code>EventEmitter</code>][]。</p>
<p><code>net.Socket</code>可以被用户创建并直接与server通信。举个例子，它是通过[<code>net.createConnection()</code>][]返回的，所以用户可以使用它来与server通信。</p>
<p>当一个连接被接收时，它也能被Node.js创建并传递给用户。比如，它是通过监听在一个[<code>net.Server</code>][]上的[<code>&apos;connection&apos;</code>][]事件触发而获得的，那么用户可以使用它来与客户端通信。</p>
<h3>new net.Socket([options])<span><a class="mark" href="#net_new_net_socket_options" id="net_new_net_socket_options">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.3.4</span>
</div><p>创建一个 socket 对象。</p>
<ul>
<li><code>options</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a> 可用选项有：<ul>
<li><code>fd</code>: 
            <a href="javascript:;" class="type">&lt;number&gt;</a> 如果指定了该参数，则使用一个给定的文件描述符包装一个已存在的 socket，否则将创建一个新的 socket。</li>
<li><code>allowHalfOpen</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 指示是否允许半打开的 TCP 连接。详情查看 [<code>net.createServer()</code>][] 和 [<code>&apos;end&apos;</code>][] 事件。默认是 <code>false</code>。</li>
<li><code>readable</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 当传递了 <code>fd</code> 时允许读取 socket，否则忽略。默认 <code>false</code>。</li>
<li><code>writable</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 当传递了 <code>fd</code> 时允许写入 socket，否则忽略。默认 <code>false</code>。</li>
</ul>
</li>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a></li>
</ul>
<p>新创建的 socket 可以是 TCP socket 也可以是 [IPC][] 端点流，取决于它连接 [<code>connect()</code>][<code>socket.connect()</code>] 到什么。</p>
<h3>&apos;close&apos; 事件<span><a class="mark" href="#net_event_close_1" id="net_event_close_1">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>had_error</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 如果 socket 有传输错误就为 true。</li>
</ul>
<p>一旦 socket 完全关闭就发出该事件。参数 <code>had_error</code> 是 boolean 类型，表明 socket 被关闭是否取决于传输错误。</p>
<h3>&apos;connect&apos; 事件<span><a class="mark" href="#net_event_connect" id="net_event_connect">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当一个 socket 连接成功建立的时候触发该事件。
查看 [<code>net.createConnection()</code>][]。</p>
<h3>&apos;data&apos; 事件<span><a class="mark" href="#net_event_data" id="net_event_data">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>
            <a href="buffer.html#buffer_class_buffer" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>当接收到数据的时触发该事件。<code>data</code> 参数是一个 <code>Buffer</code> 或 <code>String</code>。数据编码由 <code>socket.setEncoding()</code> 设置。（在 [Readable Stream][] 章节查看更多信息。）</p>
<p>注意当 <code>Socket</code> 发送 <code>data</code> 事件的时候，如果没有监听者<strong>数据将会丢失</strong>。</p>
<h3>&apos;drain&apos; 事件<span><a class="mark" href="#net_event_drain" id="net_event_drain">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当写入缓冲区变为空时触发。可以用来做上传节流。</p>
<p>也可以查看：<code>socket.write()</code> 的返回值</p>
<h3>&apos;end&apos; 事件<span><a class="mark" href="#net_event_end" id="net_event_end">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当 socket 的另一端发送一个 FIN 包的时候触发，从而结束 socket 的可读端。</p>
<p>默认情况下（<code>allowHalfOpen</code>为<code>false</code>），socket 将发送一个 FIN 数据包，并且一旦写出它的等待写入队列就销毁它的文件描述符。当然，如果 <code>allowHalfOpen</code> 为 <code>true</code>，socket 就不会自动结束 [<code>end()</code>][<code>socket.end()</code>] 它的写入端，允许用户写入任意数量的数据。用户必须调用 [<code>end()</code>][<code>socket.end()</code>] 显示地结束这个连接（例如发送一个 FIN 数据包。）</p>
<h3>&apos;error&apos; 事件<span><a class="mark" href="#net_event_error_1" id="net_event_error_1">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>
            <a href="javascript:;" class="type">&lt;Error&gt;</a></li>
</ul>
<p>当错误发生时触发。<code>&apos;close&apos;</code> 事件也会紧接着该事件被触发。</p>
<h3>&apos;lookup&apos; 事件<span><a class="mark" href="#net_event_lookup" id="net_event_lookup">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v5.10.0</td>
<td><p>The <code>host</code> parameter is supported now.</p>
</td></tr>
<tr><td>v0.11.3</td>
<td><p><span>新增于: v0.11.3</span></p>
</td></tr>
</tbody></table>
</details>
</div><p>在找到主机之后创建连接之前触发。不可用于 UNIX socket。</p>
<ul>
<li><code>err</code> 
            <a href="javascript:;" class="type">&lt;Error&gt;</a> | 
            <a href="javascript:;" class="type">&lt;null&gt;</a> 错误对象。查看 [<code>dns.lookup()</code>][]。</li>
<li><code>address</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> IP 地址。</li>
<li><code>family</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> | 
            <a href="javascript:;" class="type">&lt;null&gt;</a> 地址类型。查看 [<code>dns.lookup()</code>][]。</li>
<li><code>host</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 主机。</li>
</ul>
<h3>&apos;timeout&apos; 事件<span><a class="mark" href="#net_event_timeout" id="net_event_timeout">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>当 socket 超时的时候触发。该事件只是用来通知 socket 已经闲置。用户必须手动关闭。</p>
<p>也可以查看：[<code>socket.setTimeout()</code>][]</p>
<h3>socket.address()<span><a class="mark" href="#net_socket_address" id="net_socket_address">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>返回操作系统报告的 socket 的地址、地址族和端口。返回的对象有三个属性，例如：
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code></p>
<h3>socket.bufferSize<span><a class="mark" href="#net_socket_buffersize" id="net_socket_buffersize">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.3.8</span>
</div><p><code>net.Socket</code> 具有该属性，<code>socket.write()</code> 工作时需要。它可以帮助用户快速启动和运行。计算机（处理速度）不能总是跟上 socket 的写入速度 - 网络连接可能太慢了。 Node.js 内部将维护一个写入 socket 的数据队列，并在可能的时候将数据发送出去。（内部实现是对 socket 的文件描述符进行轮训其是否是可写状态。）</p>
<p>使用内部缓冲的结果是可能造成内存的增长。此属性显示当前即将被写入的缓冲的字符数。（字符串的数目大致等于即将被写入的字节，但缓冲可能包含字符串，而字符串是惰性编码的，所以实际的字节数是不知道的。）</p>
<p>对处理大量或持续增长的 <code>bufferSize</code> 有经验的用户应该注意使用 [<code>socket.pause()</code>][] and [<code>socket.resume()</code>][] 对他们程序中的数据流进行节流。</p>
<h3>socket.bytesRead<span><a class="mark" href="#net_socket_bytesread" id="net_socket_bytesread">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.3</span>
</div><p>接收的字节数量。</p>
<h3>socket.bytesWritten<span><a class="mark" href="#net_socket_byteswritten" id="net_socket_byteswritten">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.3</span>
</div><p>发送的字节数量。</p>
<h3>socket.connect()<span><a class="mark" href="#net_socket_connect" id="net_socket_connect">#</a></span></h3>
<p>在给定的套接字上启动一个连接。</p>
<p>可能的签名：</p>
<ul>
<li>[socket.connect(options[, connectListener])][<code>socket.connect(options)</code>]</li>
<li>[socket.connect(path[, connectListener])][<code>socket.connect(path)</code>] 用于 [IPC][] 连接。</li>
<li>[socket.connect(port[, host][, connectListener])][<code>socket.connect(port, host)</code>] 用于 TCP 。</li>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> socket 自身。</li>
</ul>
<p>该方法是异步的。当连接建立了的时候，[<code>&apos;connect&apos;</code>][] 事件将会被触发。如果连接过程中有问题，[<code>&apos;error&apos;</code>][] 事件将会代替 [<code>&apos;connect&apos;</code>][] 事件被触发，并将错误信息传递给 [<code>&apos;error&apos;</code>][] 监听器。
最后一个参数 <code>connectListener</code>，如果指定了，将会被添加为 [<code>&apos;connect&apos;</code>][] 事件的。</p>
<h4>socket.connect(options[, connectListener])<span><a class="mark" href="#net_socket_connect_options_connectlistener" id="net_socket_connect_options_connectlistener">#</a></span></h4>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.0.0</td>
<td><p>The <code>hints</code> option defaults to <code>0</code> in all cases now. Previously, in the absence of the <code>family</code> option it would default to <code>dns.ADDRCONFIG | dns.V4MAPPED</code>.</p>
</td></tr>
<tr><td>v5.11.0</td>
<td><p>The <code>hints</code> option is supported now.</p>
</td></tr>
<tr><td>v0.1.90</td>
<td><p><span>新增于: v0.1.90</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>options</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a></li>
<li><code>connectListener</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> [<code>socket.connect()</code>][] 的通用参数。将会被添加为 [<code>&apos;connect&apos;</code>][] 事件的监听器。</li>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 自身。</li>
</ul>
<p>在给定的 socket 上初始化一个连接。通常该方法是不需要的，应该使用 [<code>net.createConnection()</code>][] 来创建和打开 socket。一般只在实现一个自定义的 Socket 的时候使用该方法。</p>
<p>对于 TCP 连接可能的 <code>options</code> 有：</p>
<ul>
<li><code>port</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> 必须。Socket 连接的端口。</li>
<li><code>host</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> Socket 连接的主机。默认是 <code>&apos;localhost&apos;</code>.</li>
<li><code>localAddress</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> Socket 连接的本地地址。</li>
<li><code>localPort</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> Socket 连接的本地端口。</li>
<li><code>family</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> IP栈的版本，可以是4或6。默认值为4。</li>
<li><code>hints</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> 可选的[<code>dns.lookup()</code> hints][].</li>
<li><code>lookup</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> 自定义的 lookup 方法。默认是 [<code>dns.lookup()</code>][].</li>
</ul>
<p>对于 [IPC][] 连接可能的 <code>options</code> 有：</p>
<ul>
<li><code>path</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 必须。客户端连接的路径。查看 [Identifying paths for IPC connections][]。如果提供了，则以上的 TCP 选项都会被忽略。</li>
</ul>
<p>返回 <code>socket</code>.</p>
<h4>socket.connect(path[, connectListener])<span><a class="mark" href="#net_socket_connect_path_connectlistener" id="net_socket_connect_path_connectlistener">#</a></span></h4>
<div class="signature"><ul>
<li><code>path</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 客户端连接的路径. 查看 [Identifying paths for IPC connections][]。</li>
<li><code>connectListener</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> [<code>socket.connect()</code>][] 方法的通用参数。将被添加为 [<code>&apos;connect&apos;</code>][] 事件的监听器。</li>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 自身。</li>
</ul>
</div><p>在给定的 socket 上初始化 [IPC][] 。</p>
<p>相当使用 <code>{ path: path }</code> 作为 <code>options</code> 调用 [<code>socket.connect(options[, connectListener])</code>][<code>socket.connect(options)</code>] 方法的别名。</p>
<p>返回 <code>socket</code>。</p>
<h4>socket.connect(port[, host][, connectListener])<span><a class="mark" href="#net_socket_connect_port_host_connectlistener" id="net_socket_connect_port_host_connectlistener">#</a></span></h4>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>port</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> 客户端连接的端口。</li>
<li><code>host</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 客户端连接的主机。</li>
<li><code>connectListener</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> [<code>socket.connect()</code>][] 方法的通用参数。将会被添加为 [<code>&apos;connect&apos;</code>][] 事件的监听器。</li>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身。</li>
</ul>
<p>在给定的 socket 上初始化一个 TCP 连接。</p>
<p>使用 <code>{port: port, host: host}</code> 作为 <code>options</code> 调用 [<code>socket.connect(options[, connectListener])</code>][<code>socket.connect(options)</code>] 方法的别名。</p>
<p>返回 <code>socket</code>。</p>
<h3>socket.connecting<span><a class="mark" href="#net_socket_connecting" id="net_socket_connecting">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v6.1.0</span>
</div><p>如果为 <code>true</code> 则[<code>socket.connect(options[, connectListener])</code>][<code>socket.connect(options)</code>] 被调用但还未结束。当发送 <code>connect</code> 事件或调用 [<code>socket.connect(options[, connectListener])</code>][<code>socket.connect(options)</code>] 的回调函数的时候会被设置为 <code>false</code>。</p>
<h3>socket.destroy([exception])<span><a class="mark" href="#net_socket_destroy_exception" id="net_socket_destroy_exception">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a></li>
</ul>
<p>确保在该 socket 上不再有 I/O 活动。仅在出现错误的时候才需要（如解析错误等）。</p>
<p>如果制定了 <code>exception</code>，则将会触发一个 [<code>&apos;error&apos;</code>][] 事件，任何监听器都将接收到 <code>exception</code> 作为一个参数。</p>
<h3>socket.destroyed<span><a class="mark" href="#net_socket_destroyed" id="net_socket_destroyed">#</a></span></h3>
<p>一个布尔值，用来指示连接是否已经被销毁。一旦连接被销毁就不能再使用它传输任何数据。</p>
<h3>socket.end([data][, encoding])<span><a class="mark" href="#net_socket_end_data_encoding" id="net_socket_end_data_encoding">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身。</li>
</ul>
<p>半关闭 socket。例如发送一个 FIN 包。服务端仍可以发送数据。</p>
<p>如果指定了 <code>data</code>，则相当于调用 <code>socket.write(data, encoding)</code> 之后再调用 [<code>socket.end()</code>][]。</p>
<h3>socket.localAddress<span><a class="mark" href="#net_socket_localaddress" id="net_socket_localaddress">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.9.6</span>
</div><p>远程客户端连接的本地 IP 地址字符串。例如，一个服务端正在连接到 <code>&apos;0.0.0.0&apos;</code>，客户端连接到的是 <code>&apos;192.168.1.1&apos;</code>，则 <code>socket.localAddress</code> 的值是 <code>&apos;192.168.1.1&apos;</code>。</p>
<h3>socket.localPort<span><a class="mark" href="#net_socket_localport" id="net_socket_localport">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.9.6</span>
</div><p>用数字表示的本地端口。例如 <code>80</code> 或 <code>21</code>。</p>
<h3>socket.pause()<span><a class="mark" href="#net_socket_pause" id="net_socket_pause">#</a></span></h3>
<div class="signature"><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身。</li>
</ul>
</div><p>暂停读写数据。也就是说，[<code>&apos;data&apos;</code>][] 将不会再被触发。可以用于上传节流。</p>
<h3>socket.ref()<span><a class="mark" href="#net_socket_ref" id="net_socket_ref">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身</li>
</ul>
<p>与 unref 相反，在一个已经调用 unref 的 socket 中调用 ref，如果 socket 是仅存的 socket，则程序不会退出（默认）。对一个已经调用 ref 的 socket 再次调用 ref 将不会再有效果。</p>
<h3>socket.remoteAddress<span><a class="mark" href="#net_socket_remoteaddress" id="net_socket_remoteaddress">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.10</span>
</div><p>用字符串表示的远程 IP 地址。例如 <code>&apos;74.125.127.100&apos;</code> 或 <code>&apos;2001:4860:a005::68&apos;</code>。如果 socket 被销毁了（如客户端已经失去连接）则其值为 <code>undefined</code>。</p>
<h3>socket.remoteFamily<span><a class="mark" href="#net_socket_remotefamily" id="net_socket_remotefamily">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div><p>用字符串表示的远程 IP 协议族。<code>&apos;IPv4&apos;</code> 或 <code>&apos;IPv6&apos;</code>。</p>
<h3>socket.remotePort<span><a class="mark" href="#net_socket_remoteport" id="net_socket_remoteport">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.10</span>
</div><p>用数字表示的远程端口。例如 <code>80</code> 或 <code>21</code>。</p>
<h3>socket.resume()<span><a class="mark" href="#net_socket_resume" id="net_socket_resume">#</a></span></h3>
<div class="signature"><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身</li>
</ul>
</div><p>在调用 [<code>socket.pause()</code>][] 之后恢复读取数据。</p>
<h3>socket.setEncoding([encoding])<span><a class="mark" href="#net_socket_setencoding_encoding" id="net_socket_setencoding_encoding">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身</li>
</ul>
<p>设置作为可读流（[Readable Stream][]）的编码。在 [<code>stream.setEncoding()</code>][] 查看更多详情。</p>
<h3>socket.setKeepAlive([enable][, initialDelay])<span><a class="mark" href="#net_socket_setkeepalive_enable_initialdelay" id="net_socket_setkeepalive_enable_initialdelay">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.92</span>
</div><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身。</li>
</ul>
<p>启用/禁用长连接功能， 并且在第一个长连接探针被发送到一个空闲的 socket 之前可选则配置初始延迟。<code>enable</code> 默认为 <code>false</code>。</p>
<p><code>initialDelay</code>（毫秒）用来设置接收到最后一个数据包和发送第一个长连接探针之间的延迟。将 initialDelay 设置为 0，则会保持默认值（或之前设置的值）不变。默认是 <code>0</code>。</p>
<h3>socket.setNoDelay([noDelay])<span><a class="mark" href="#net_socket_setnodelay_nodelay" id="net_socket_setnodelay_nodelay">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身。</li>
</ul>
<p>禁止 Nagle 。默认情况下 TCP 连接使用 Nagle 算法，在发送之前缓冲数据。将 <code>noDelay</code> 设置为 <code>true</code> 将会在每次 <code>socket.write()</code> 被调用的时候立即发送数据。<code>noDelay</code>默认是 <code>true</code>。</p>
<h3>socket.setTimeout(timeout[, callback])<span><a class="mark" href="#net_socket_settimeout_timeout_callback" id="net_socket_settimeout_timeout_callback">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身。</li>
</ul>
<p>当 socket 在 <code>timeout</code> 毫秒不活动之后将其设置为超时状态。默认 <code>net.Socket</code> 没有超时。</p>
<p>当一个闲置的超时被触发，socket 将会收到一个 [<code>&apos;timeout&apos;</code>][] 事件，但连接不会被断开。用户必须手动调用 [<code>socket.end()</code>][] 或 [<code>socket.destroy()</code>][] 来断开连接。</p>
<pre><code class="lang-js">socket.setTimeout(3000);
socket.on(&apos;timeout&apos;, () =&gt; {
  console.log(&apos;socket timeout&apos;);
  socket.end();
});
</code></pre>
<p>如果 <code>timeout</code> 是 0，则存在的闲置超时将会被禁止。</p>
<p>可选的 <code>callback</code> 参数将会被当作一个时间监听器被添加到 [<code>&apos;timeout&apos;</code>][] 事件。</p>
<h3>socket.unref()<span><a class="mark" href="#net_socket_unref" id="net_socket_unref">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div><ul>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> Socket 本身。</li>
</ul>
<p>如果活跃的 socket 是事件系统中仅存的 socket，则调用 <code>unref</code> 将会允许程序退出。对一个已经调用了 <code>unref</code> 的 socket 再调用 <code>unref</code> 无效。</p>
<h3>socket.write(data[, encoding][, callback])<span><a class="mark" href="#net_socket_write_data_encoding_callback" id="net_socket_write_data_encoding_callback">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>在 socket 上发送数据。第二个参数制定了字符串的编码 - 默认是 UTF8 编码。</p>
<p>如果全部数据都成功刷新到内核的缓冲则返回 <code>true</code>。如果全部或部分数据在用户内中排队，则返回 <code>false</code>。当缓冲再次空闲的时候将触发 [<code>&apos;drain&apos;</code>][] 事件。</p>
<p>当数据最终都被写出之后，可选的 <code>callback</code> 参数将会被执行 - 可能不会立即执行。</p>
<h2>net.connect()<span><a class="mark" href="#net_net_connect" id="net_net_connect">#</a></span></h2>
<p>[<code>net.createConnection()</code>][<code>net.createConnection()</code>] 的别名。</p>
<p>可能的签名：</p>
<ul>
<li>[<code>net.connect(options[, connectListener])</code>][<code>net.connect(options)</code>]</li>
<li>[<code>net.connect(path[, connectListener])</code>][<code>net.connect(path)</code>] 用于 [IPC][] 连接。</li>
<li>[<code>net.connect(port[, host][, connectListener])</code>][<code>net.connect(port, host)</code>] 用于 TCP 连接。</li>
</ul>
<h3>net.connect(options[, connectListener])<span><a class="mark" href="#net_net_connect_options_connectlistener" id="net_net_connect_options_connectlistener">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.7.0</span>
</div><p>[<code>net.createConnection(options[, connectListener])</code>][<code>net.createConnection(options)</code>] 的别名。</p>
<h3>net.connect(path[, connectListener])<span><a class="mark" href="#net_net_connect_path_connectlistener" id="net_net_connect_path_connectlistener">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>[<code>net.createConnection(path[, connectListener])</code>][<code>net.createConnection(path)</code>] 的别名。</p>
<h3>net.connect(port[, host][, connectListener])<span><a class="mark" href="#net_net_connect_port_host_connectlistener" id="net_net_connect_port_host_connectlistener">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><p>[<code>net.createConnection(port[, host][, connectListener])</code>][<code>net.createConnection(port, host)</code>] 的别名。</p>
<h2>net.createConnection()<span><a class="mark" href="#net_net_createconnection" id="net_net_createconnection">#</a></span></h2>
<p>一个用于创建 [<code>net.Socket</code>][] 的工厂函数，立即使用 [<code>socket.connect()</code>][] 初始化链接，然后返回启动连接的 <code>net.Socket</code>。</p>
<p>当连接建立之后，在返回的 socket 上将触发一个 [<code>&apos;connect&apos;</code>][] 事件。若制定了最后一个参数 <code>connectListener</code>，则它将会被添加到 [<code>&apos;connect&apos;</code>][] 事件作为一个监听器。</p>
<p>可能的签名有：</p>
<ul>
<li>[<code>net.createConnection(options[, connectListener])</code>][<code>net.createConnection(options)</code>]</li>
<li>[<code>net.createConnection(path[, connectListener])</code>][<code>net.createConnection(path)</code>] 用于 [IPC][] 连接。</li>
<li>[<code>net.createConnection(port[, host][, connectListener])</code>][<code>net.createConnection(port, host)</code>] 用于 TCP 连接。</li>
</ul>
<p><em>注意</em>: The [<code>net.connect()</code>][] 函数也是该函数的别名。</p>
<h3>net.createConnection(options[, connectListener])<span><a class="mark" href="#net_net_createconnection_options_connectlistener" id="net_net_createconnection_options_connectlistener">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>options</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a> 必须。调用 [<code>new net.Socket([options])</code>][<code>new net.Socket(options)</code>] 和 [<code>socket.connect(options[, connectListener])</code>][<code>socket.connect(options)</code>] 方法都会传入。</li>
<li><code>connectListener</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> [<code>net.createConnection()</code>][] 方法的通用参数。如果制定了，将被添加为返回 socket 上的 [<code>&apos;connect&apos;</code>][] 事件上的监听器。</li>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> 新创建的 socket，用于开始连接。</li>
</ul>
<p>可选的选项，查看 [<code>new net.Socket([options])</code>][<code>new net.Socket(options)</code>] 和 [<code>socket.connect(options[, connectListener])</code>][<code>socket.connect(options)</code>]。</p>
<p>附加的选项：</p>
<ul>
<li><code>timeout</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> 如果设置，将会用来在 socket 创建之后连接开始之前调用 [<code>socket.setTimeout(timeout)</code>][]。</li>
</ul>
<p>下面是在 [<code>net.createServer()</code>][] 章节描述的 server 的客户端示例：</p>
<pre><code class="lang-js">const net = require(&apos;net&apos;);
const client = net.createConnection({ port: 8124 }, () =&gt; {
  //&apos;connect&apos; listener
  console.log(&apos;connected to server!&apos;);
  client.write(&apos;world!\r\n&apos;);
});
client.on(&apos;data&apos;, (data) =&gt; {
  console.log(data.toString());
  client.end();
});
client.on(&apos;end&apos;, () =&gt; {
  console.log(&apos;disconnected from server&apos;);
});
</code></pre>
<p>如果要连接到 <code>/tmp/echo.sock</code>，第二行只需要改为：</p>
<pre><code class="lang-js">const client = net.createConnection({ path: &apos;/tmp/echo.sock&apos; });
</code></pre>
<h3>net.createConnection(path[, connectListener])<span><a class="mark" href="#net_net_createconnection_path_connectlistener" id="net_net_createconnection_path_connectlistener">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>path</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> Socket 应该被连接到的路径。将会被传入到 [<code>socket.connect(path[, connectListener])</code>][<code>socket.connect(path)</code>]。查看 [Identifying paths for IPC connections][]。</li>
<li><code>connectListener</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> [<code>net.createConnection()</code>][] 方法的通用参数，在初始化的 socket 上的 <code>&apos;connect&apos;</code> 事件的 &quot;once&quot; 监听器。将会被传入到 [<code>socket.connect(path[, connectListener])</code>][<code>socket.connect(path)</code>]。</li>
<li>Returns: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> 新创建的 socket，用来开始连接。</li>
</ul>
<p>初始化一个 [IPC][] 连接。</p>
<p>该方法使用所有默认选项创建一个新的 [<code>net.Socket</code>][]，使用 [<code>socket.connect(path[, connectListener])</code>][<code>socket.connect(path)</code>] 立即初始化连接，然后返回初始化连接的 <code>net.Socket</code>。</p>
<h3>net.createConnection(port[, host][, connectListener])<span><a class="mark" href="#net_net_createconnection_port_host_connectlistener" id="net_net_createconnection_port_host_connectlistener">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><p><code>port</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> 套接字应该连接的端口号. 会
传给[<code>socket.connect(port[, host][, connectListener])</code>][<code>socket.connect(port, host)</code>].</p>
</li>
<li><p><code>host</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 套接字应该连接的主机名. 会
传给[<code>socket.connect(port[, host][, connectListener])</code>][<code>socket.connect(port, host)</code>].
 <strong>默认:</strong> <code>&apos;localhost&apos;</code></p>
</li>
<li><code>connectListener</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> 
[<code>net.createConnection()</code>][] 的常见参数, 在初始化套接字时
对<code>&apos;connect&apos;</code> 事件的&quot;一次性&quot;监听器， 会
传给[<code>socket.connect(path[, connectListener])</code>][<code>socket.connect(port, host)</code>].</li>
<li>返回值: 
            <a href="#net_class_net_socket" class="type">&lt;net.Socket&gt;</a> 用于开启连接的新创建的套接字.</li>
</ul>
<p>初始化一个TCP连接</p>
<p>这个函数用默认配置创建一个新的[<code>net.Socket</code>][]，然后[<code>socket.connect(port[, host][, connectListener])</code>][<code>socket.connect(port, host)</code>]初始化一个连接，并返回开启连接的那个 <code>net.Socket</code>。</p>
<h2>net.createServer([options][, connectionListener])<span><a class="mark" href="#net_net_createserver_options_connectionlistener" id="net_net_createserver_options_connectionlistener">#</a></span></h2>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div><p>Creates a new TCP or [IPC][] server.
创建一个新的TCP或[IPC][]服务。</p>
<ul>
<li><code>options</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a><ul>
<li><code>allowHalfOpen</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 表示是否允许一个半开的TCP连接。
<strong>默认值:</strong> <code>false</code></li>
<li><code>pauseOnConnect</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 一旦来了连接，是否暂停套接字。
<strong>默认值:</strong> <code>false</code></li>
</ul>
</li>
<li><code>connectionListener</code> 
            <a href="javascript:;" class="type">&lt;Function&gt;</a> 为[<code>&apos;connection&apos;</code>][] 事件自动设置一个监听器。</li>
<li>返回: <span class="type">&lt;net.Server&gt;</span></li>
</ul>
<p>如果 <code>allowHalfOpen</code> 被设置为<code>true</code>, 那么当[<code>socket.end()</code>][] 被显式调用时,
如果对边套接字发送了一个FIN包，服务只会返回一个FIN数据包，
这会持续到后来连接处在半闭状态 (不可读但是可写)。
请查看[<code>&apos;end&apos;</code>][] 事件和 [RFC 1122][half-closed] (4.2.2.13节) 获取更多信息。</p>
<p>如果 <code>pauseOnConnect</code> 被设置为 <code>true</code>, 那么与连接相关的套接字都会暂停，也不会从套接字句柄读取数据。
这样就允许连接在进程之间传递，避免数据被最初的进程读取。
如果想从一个暂停的套接字开始读数据，请调用[<code>socket.resume()</code>][]</p>
<p>服务可以是一个TCP服务或者一个 [IPC][] 服务,
这取决于[<code>listen()</code>][<code>server.listen()</code>] 监听什么</p>
<p>这是一个简单的TCP回声服务器在8124端口上监听连接的例子：</p>
<pre><code class="lang-js">const net = require(&apos;net&apos;);
const server = net.createServer((c) =&gt; {
  // &apos;connection&apos; listener
  console.log(&apos;client connected&apos;);
  c.on(&apos;end&apos;, () =&gt; {
    console.log(&apos;client disconnected&apos;);
  });
  c.write(&apos;hello\r\n&apos;);
  c.pipe(c);
});
server.on(&apos;error&apos;, (err) =&gt; {
  throw err;
});
server.listen(8124, () =&gt; {
  console.log(&apos;server bound&apos;);
});
</code></pre>
<p>用 <code>telnet</code>测试:</p>
<pre><code class="lang-console">$ telnet localhost 8124
</code></pre>
<p>想监听 <code>/tmp/echo.sock</code> 只需改最后三行为：</p>
<pre><code class="lang-js">server.listen(&apos;/tmp/echo.sock&apos;, () =&gt; {
  console.log(&apos;server bound&apos;);
});
</code></pre>
<p>用 <code>nc</code> 连一个 UNIX 域套接字服务器:</p>
<pre><code class="lang-console">$ nc -U /tmp/echo.sock
</code></pre>
<h2>net.isIP(input)<span><a class="mark" href="#net_net_isip_input" id="net_net_isip_input">#</a></span></h2>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div><p>测试 input 是否是 IP 地址。无效的字符串则返回 0，IPv4 地址则返回 4，IPv6的地址则返回 6。</p>
<h2>net.isIPv4(input)<span><a class="mark" href="#net_net_isipv4_input" id="net_net_isipv4_input">#</a></span></h2>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div><p>如果 input 是 IPv4 地址则返回 true，否则返回 false。</p>
<h2>net.isIPv6(input)<span><a class="mark" href="#net_net_isipv6_input" id="net_net_isipv6_input">#</a></span></h2>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div><p>如果 input 是 IPv6 地址则返回 true，否则返回 false。
[<code>&apos;close&apos;</code>]: #net_event_close
[<code>&apos;connect&apos;</code>]: #net_event_connect
[<code>&apos;connection&apos;</code>]: #net_event_connection
[<code>&apos;data&apos;</code>]: #net_event_data
[<code>&apos;drain&apos;</code>]: #net_event_drain
[<code>&apos;end&apos;</code>]: #net_event_end
[<code>&apos;error&apos;</code>]: #net_event_error_1
[<code>&apos;listening&apos;</code>]: #net_event_listening
[<code>&apos;timeout&apos;</code>]: #net_event_timeout
[<code>EventEmitter</code>]: events.html#events_class_eventemitter
[<code>child_process.fork()</code>]: child_process.html#child_process_child_process_fork_modulepath_args_options
[<code>dns.lookup()</code> hints]: dns.html#dns_supported_getaddrinfo_flags
[<code>dns.lookup()</code>]: dns.html#dns_dns_lookup_hostname_options_callback
[<code>net.Server</code>]: #net_class_net_server
[<code>net.Socket</code>]: #net_class_net_socket
[<code>net.connect()</code>]: #net_net_connect
[<code>net.connect(options)</code>]: #net_net_connect_options_connectlistener
[<code>net.connect(path)</code>]: #net_net_connect_path_connectlistener
[<code>net.connect(port, host)</code>]: #net_net_connect_port_host_connectlistener
[<code>net.createConnection()</code>]: #net_net_createconnection
[<code>net.createConnection(options)</code>]: #net_net_createconnection_options_connectlistener
[<code>net.createConnection(path)</code>]: #net_net_createconnection_path_connectlistener
[<code>net.createConnection(port, host)</code>]: #net_net_createconnection_port_host_connectlistener
[<code>net.createServer()</code>]: #net_net_createserver_options_connectionlistener
[<code>new net.Socket(options)</code>]: #net_new_net_socket_options
[<code>server.close()</code>]: #net_server_close_callback
[<code>server.getConnections()</code>]: #net_server_getconnections_callback
[<code>server.listen()</code>]: #net_server_listen
[<code>server.listen(handle)</code>]: #net_server_listen_handle_backlog_callback
[<code>server.listen(options)</code>]: #net_server_listen_options_callback
[<code>server.listen(path)</code>]: #net_server_listen_path_backlog_callback
[<code>server.listen(port, host)</code>]: #net_server_listen_port_host_backlog_callback
[<code>socket.connect()</code>]: #net_socket_connect
[<code>socket.connect(options)</code>]: #net_socket_connect_options_connectlistener
[<code>socket.connect(path)</code>]: #net_socket_connect_path_connectlistener
[<code>socket.connect(port, host)</code>]: #net_socket_connect_port_host_connectlistener
[<code>socket.destroy()</code>]: #net_socket_destroy_exception
[<code>socket.end()</code>]: #net_socket_end_data_encoding
[<code>socket.pause()</code>]: #net_socket_pause
[<code>socket.resume()</code>]: #net_socket_resume
[<code>socket.setTimeout()</code>]: #net_socket_settimeout_timeout_callback
[<code>socket.setTimeout(timeout)</code>]: #net_socket_settimeout_timeout_callback
[<code>stream.setEncoding()</code>]: stream.html#stream_readable_setencoding_encoding
[IPC]: #net_ipc_support
[Identifying paths for IPC connections]: #net_identifying_paths_for_ipc_connections
[Readable Stream]: stream.html#stream_class_stream_readable
[duplex stream]: stream.html#stream_class_stream_duplex
[half-closed]: <a href="javascript:;">https://tools.ietf.org/html/rfc1122</a>
[socket(7)]: <a href="javascript:;">http://man7.org/linux/man-pages/man7/socket.7.html</a>
[unspecified IPv4 address]: <a href="javascript:;">https://en.wikipedia.org/wiki/0.0.0.0</a>
[unspecified IPv6 address]: <a href="javascript:;">https://en.wikipedia.org/wiki/IPv6_address#Unspecified_address</a></p>

      </div>
    </div>

    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="index.html" title="Go back to the home page">
          Node.js 中文文档 | Node.js 中文网
        </a>
      </div>
      
        <!-- [start-include:_toc.md] -->
<ul>
<li><a href="documentation.html">关于本文档</a></li>
<li><a href="synopsis.html">用法与例子</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a href="assert.html">断言测试</a></li>
<li><a href="async_hooks.html">异步钩子（Async Hooks）</a></li>
<li><a href="buffer.html">缓存（Buffer）</a></li>
<li><a href="addons.html">C++ 插件</a></li>
<li><a href="n-api.html">C/C++ 插件 - N-API</a></li>
<li><a href="child_process.html">子进程</a></li>
<li><a href="cluster.html">集群（Cluster）</a></li>
<li><a href="cli.html">命令行参数</a></li>
<li><a href="console.html">控制台（Console）</a></li>
<li><a href="crypto.html">加密（Crypto）</a></li>
<li><a href="debugger.html">调试器</a></li>
<li><a href="deprecations.html">废弃的 API</a></li>
<li><a href="dns.html">DNS</a></li>
<li><a href="domain.html">域（Domain）</a></li>
<li><a href="esm.html">ECMAScript 模块</a></li>
<li><a href="errors.html">错误（Errors）</a></li>
<li><a href="events.html">事件（Events）</a></li>
<li><a href="fs.html">文件系统</a></li>
<li><a href="globals.html">全局对象（Globals）</a></li>
<li><a href="http.html">HTTP</a></li>
<li><a href="http2.html">HTTP/2</a></li>
<li><a href="https.html">HTTPS</a></li>
<li><a href="inspector.html">检查工具（Inspector）</a></li>
<li><a href="intl.html">国际化</a></li>
<li><a href="modules.html">模块（Modules）</a></li>
<li><a href="">网络（Net）</a></li>
<li><a href="os.html">操作系统（OS）</a></li>
<li><a href="path.html">路径（Path）</a></li>
<li><a href="perf_hooks.html">性能钩子（Performance Hooks）</a></li>
<li><a href="process.html">进程</a></li>
<li><a href="punycode.html">Punycode</a></li>
<li><a href="querystring.html">查询字符串</a></li>
<li><a href="readline.html">逐行读取</a></li>
<li><a href="repl.html">交互式解释器（REPL）</a></li>
<li><a href="stream.html">流（Stream）</a></li>
<li><a href="string_decoder.html">字符串解码</a></li>
<li><a href="timers.html">定时器（Timers）</a></li>
<li><a href="tls.html">安全传输层（TLS/SSL）</a></li>
<li><a href="tracing.html">事件跟踪（Tracing）</a></li>
<li><a href="tty.html">TTY</a></li>
<li><a href="dgram.html">UDP / 数据报</a></li>
<li><a href="url.html">URL</a></li>
<li><a href="util.html">工具集</a></li>
<li><a href="v8.html">V8</a></li>
<li><a href="vm.html">虚拟机（VM）</a></li>
<li><a href="zlib.html">压缩（ZLIB）</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a href="javascript:;">GitHub 仓库和问题跟踪</a></li>
<li><a href="javascript:;">邮件列表</a></li>
</ul>
<!-- [end-include:_toc.md] -->

      
    </div>
  </div>
  <script src="static/js/sh_main.js"></script>
  <script src="static/js/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>
