<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>缓存（Buffer） | Node.js 中文文档 | Node.js 中文网</title>
  <meta name="description" content="Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。">
  <link rel="stylesheet" href="static/css/style.css">
  <link rel="stylesheet" href="static/css/sh.css">
  
  <link rel="apple-touch-icon" href="static/picture/apple-touch-icon.png">
  
  
  

</head>
<body class="alt apidoc" id="api-section-buffer">
  <div id="content" class="clearfix">
    <div id="column1" data-id="buffer" class="interior">
      <header>
        <h1>Node.js v8.x 中文文档</h1>
        <hr>
      </header>

      <div id="toc">
        <h2>目录</h2>
        <ul>
<li><span class="stability_2"><a href="#buffer_buffer">Buffer (缓冲)</a></span><ul>
<li><span class="stability_undefined"><a href="#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe"><code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code></a></span><ul>
<li><span class="stability_undefined"><a href="#buffer_the_zero_fill_buffers_command_line_option"><code>--zero-fill-buffers</code> 命令行选项</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe">是什么令 <code>Buffer.allocUnsafe()</code> 和 <code>Buffer.allocUnsafeSlow()</code> 不安全？</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#buffer_buffers_and_character_encodings">Buffer 与字符编码</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buffers_and_typedarray">Buffer 与 TypedArray</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buffers_and_es6_iteration">Buffer 与 ES6 迭代器</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_buffer">Buffer 类</a></span><ul>
<li><span class="stability_0"><a href="#buffer_new_buffer_array">new Buffer(array)</a></span></li>
<li><span class="stability_0"><a href="#buffer_new_buffer_arraybuffer_byteoffset_length">new Buffer(arrayBuffer[, byteOffset [, length]])</a></span></li>
<li><span class="stability_0"><a href="#buffer_new_buffer_buffer">new Buffer(buffer)</a></span></li>
<li><span class="stability_0"><a href="#buffer_new_buffer_size">new Buffer(size)</a></span></li>
<li><span class="stability_0"><a href="#buffer_new_buffer_string_encoding">new Buffer(string[, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_alloc_size_fill_encoding">类方法：Buffer.alloc(size[, fill[, encoding]])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_allocunsafe_size">类方法：Buffer.allocUnsafe(size)</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_allocunsafeslow_size">类方法：Buffer.allocUnsafeSlow(size)</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_bytelength_string_encoding">类方法：Buffer.byteLength(string[, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_compare_buf1_buf2">类方法：Buffer.compare(buf1, buf2)</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_concat_list_totallength">类方法：Buffer.concat(list[, totalLength])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_from_array">类方法：Buffer.from(array)</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length">类方法：Buffer.from(arrayBuffer[, byteOffset[, length]])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_from_buffer">类方法：Buffer.from(buffer)</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_from_string_encoding">类方法：Buffer.from(string[, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_from_object_offsetorencoding_length">Class Method: Buffer.from(object[, offsetOrEncoding[, length]])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_isbuffer_obj">类方法：Buffer.isBuffer(obj)</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_method_buffer_isencoding_encoding">类方法：Buffer.isEncoding(encoding)</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_class_property_buffer_poolsize">类属性：Buffer.poolSize</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_index">buf[index]</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_buffer">buf.buffer</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend">buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_copy_target_targetstart_sourcestart_sourceend">buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_entries">buf.entries()</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_equals_otherbuffer">buf.equals(otherBuffer)</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_fill_value_offset_end_encoding">buf.fill(value[, offset[, end]][, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_includes_value_byteoffset_encoding">buf.includes(value[, byteOffset][, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_indexof_value_byteoffset_encoding">buf.indexOf(value[, byteOffset][, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_keys">buf.keys()</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_lastindexof_value_byteoffset_encoding">buf.lastIndexOf(value[, byteOffset][, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_length">buf.length</a></span></li>
<li><span class="stability_0"><a href="#buffer_buf_parent">buf.parent</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readdoublebe_offset_noassert">buf.readDoubleBE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readdoublele_offset_noassert">buf.readDoubleLE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readfloatbe_offset_noassert">buf.readFloatBE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readfloatle_offset_noassert">buf.readFloatLE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readint8_offset_noassert">buf.readInt8(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readint16be_offset_noassert">buf.readInt16BE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readint16le_offset_noassert">buf.readInt16LE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readint32be_offset_noassert">buf.readInt32BE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readint32le_offset_noassert">buf.readInt32LE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readintbe_offset_bytelength_noassert">buf.readIntBE(offset, byteLength[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readintle_offset_bytelength_noassert">buf.readIntLE(offset, byteLength[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readuint8_offset_noassert">buf.readUInt8(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readuint16be_offset_noassert">buf.readUInt16BE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readuint16le_offset_noassert">buf.readUInt16LE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readuint32be_offset_noassert">buf.readUInt32BE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readuint32le_offset_noassert">buf.readUInt32LE(offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readuintbe_offset_bytelength_noassert">buf.readUIntBE(offset, byteLength[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_readuintle_offset_bytelength_noassert">buf.readUIntLE(offset, byteLength[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_slice_start_end">buf.slice([start[, end]])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_swap16">buf.swap16()</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_swap32">buf.swap32()</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_swap64">buf.swap64()</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_tojson">buf.toJSON()</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_tostring_encoding_start_end">buf.toString([encoding[, start[, end]]])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_values">buf.values()</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_write_string_offset_length_encoding">buf.write(string[, offset[, length]][, encoding])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writedoublebe_value_offset_noassert">buf.writeDoubleBE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writedoublele_value_offset_noassert">buf.writeDoubleLE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writefloatbe_value_offset_noassert">buf.writeFloatBE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writefloatle_value_offset_noassert">buf.writeFloatLE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeint8_value_offset_noassert">buf.writeInt8(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeint16be_value_offset_noassert">buf.writeInt16BE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeint16le_value_offset_noassert">buf.writeInt16LE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeint32be_value_offset_noassert">buf.writeInt32BE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeint32le_value_offset_noassert">buf.writeInt32LE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeintbe_value_offset_bytelength_noassert">buf.writeIntBE(value, offset, byteLength[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeintle_value_offset_bytelength_noassert">buf.writeIntLE(value, offset, byteLength[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeuint8_value_offset_noassert">buf.writeUInt8(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeuint16be_value_offset_noassert">buf.writeUInt16BE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeuint16le_value_offset_noassert">buf.writeUInt16LE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeuint32be_value_offset_noassert">buf.writeUInt32BE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeuint32le_value_offset_noassert">buf.writeUInt32LE(value, offset[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeuintbe_value_offset_bytelength_noassert">buf.writeUIntBE(value, offset, byteLength[, noAssert])</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buf_writeuintle_value_offset_bytelength_noassert">buf.writeUIntLE(value, offset, byteLength[, noAssert])</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#buffer_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buffer_kmaxlength">buffer.kMaxLength</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buffer_transcode_source_fromenc_toenc">buffer.transcode(source, fromEnc, toEnc)</a></span></li>
<li><span class="stability_0"><a href="#buffer_class_slowbuffer">SlowBuffer 类</a></span><ul>
<li><span class="stability_0"><a href="#buffer_new_slowbuffer_size">new SlowBuffer(size)</a></span></li>
</ul>
</li>
<li><span class="stability_undefined"><a href="#buffer_buffer_constants">Buffer Constants</a></span><ul>
<li><span class="stability_undefined"><a href="#buffer_buffer_constants_max_length">buffer.constants.MAX_LENGTH</a></span></li>
<li><span class="stability_undefined"><a href="#buffer_buffer_constants_max_string_length">buffer.constants.MAX_STRING_LENGTH</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
<div id="apicontent">
        <h1>Buffer (缓冲)<span><a class="mark" href="#buffer_buffer" id="buffer_buffer">#</a></span></h1>
<!--introduced_in=v0.10.0-->
<div class="api_stability api_stability_2"><a href="documentation.html#documentation_stability_index">稳定性: 2</a> - 稳定的</div><p>在 <a href="javascript:;"><code>ECMAScript 2015</code></a> (ES6) 引入 <a href="javascript:;"><code>TypedArray</code></a> 之前，JavaScript 语言没有读取或操作二进制数据流的机制。
<code>Buffer</code> 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。</p>
<p><a href="javascript:;"><code>TypedArray</code></a> 现已被添加进 ES6 中，<code>Buffer</code> 类以一种更优化、更适合 Node.js 用例的方式实现了 <a href="javascript:;"><code>Uint8Array</code></a> API。</p>
<p><code>Buffer</code> 类的实例类似于整数数组，但 <code>Buffer</code> 的大小是固定的、且在 V8 堆外分配物理内存。
<code>Buffer</code> 的大小在被创建时确定，且无法调整。</p>
<p><code>Buffer</code> 类在 Node.js 中是一个全局变量，因此无需使用 <code>require(&apos;buffer&apos;).Buffer</code>。</p>
<p>例子：</p>
<pre><code class="lang-js">// 创建一个长度为 10、且用 0 填充的 Buffer。
const buf1 = Buffer.alloc(10);

// 创建一个长度为 10、且用 0x1 填充的 Buffer。 
const buf2 = Buffer.alloc(10, 1);

// 创建一个长度为 10、且未初始化的 Buffer。
// 这个方法比调用 Buffer.alloc() 更快，
// 但返回的 Buffer 实例可能包含旧数据，
// 因此需要使用 fill() 或 write() 重写。
const buf3 = Buffer.allocUnsafe(10);

// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。
const buf4 = Buffer.from([1, 2, 3]);

// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。
const buf5 = Buffer.from(&apos;tést&apos;);

// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。
const buf6 = Buffer.from(&apos;tést&apos;, &apos;latin1&apos;);
</code></pre>
<h2><code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code><span><a class="mark" href="#buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe" id="buffer_buffer_from_buffer_alloc_and_buffer_allocunsafe">#</a></span></h2>
<p>在 Node.js v6 之前的版本中，<code>Buffer</code> 实例是通过 <code>Buffer</code> 构造函数创建的，它根据提供的参数返回不同的 <code>Buffer</code>：</p>
<ul>
<li>传一个数值作为第一个参数给 <code>Buffer()</code>（如 <code>new Buffer(10)</code>），则分配一个指定大小的新建的 <code>Buffer</code> 对象。
在 Node.js 8.0.0 之前，分配给这种 <code>Buffer</code> 实例的内存是<strong>没有</strong>初始化的，且<strong>可能包含敏感数据</strong>。
这种 <code>Buffer</code> 实例随后必须被初始化，可以使用 <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> 或写满这个 <code>Buffer</code>。
虽然这种行为是为了提高性能而<strong>有意为之的</strong>，但开发经验表明，创建一个快速但未初始化的 <code>Buffer</code> 与创建一个慢点但更安全的 <code>Buffer</code> 之间需要有更明确的区分。从 Node.js 8.0.0 开始， <code>Buffer(num)</code> 和 <code>new Buffer(num)</code> 将返回一个初始化内存之后的 <code>Buffer</code>。</li>
<li>传一个字符串、数组、或 <code>Buffer</code> 作为第一个参数，则将所传对象的数据拷贝到 <code>Buffer</code> 中。</li>
<li>传入 <a href="javascript:;"><code>ArrayBuffer</code></a> 或 <a href="javascript:;"><code>SharedArrayBuffer</code></a>，则返回一个与传入的 ArrayBuffer 共享所分配内存的 <code>Buffer</code>。</li>
</ul>
<p>因为 <code>new Buffer()</code> 的行为会根据所传入的第一个参数的值的数据类型而明显地改变，所以如果应用程序没有正确地校验传给 <code>new Buffer()</code> 的参数、或未能正确地初始化新分配的 <code>Buffer</code> 的内容，就有可能在无意中为他们的代码引入安全性与可靠性问题。</p>
<p>为了使 <code>Buffer</code> 实例的创建更可靠、更不容易出错，各种 <code>new Buffer()</code> 构造函数已被 <strong>废弃</strong>，并由 <code>Buffer.from()</code>、<a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a>、和 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 方法替代。</p>
<p><strong>开发者们应当把所有正在使用的 <code>new Buffer()</code> 构造函数迁移到这些新的 API 上。</strong></p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> 返回一个新建的包含所提供的字节数组的副本的 <code>Buffer</code>。</li>
<li>[<code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code>]<a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer)</code></a> 返回一个新建的与给定的 <a href="javascript:;"><code>ArrayBuffer</code></a> 共享同一内存的 <code>Buffer</code>。</li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> 返回一个新建的包含所提供的 <code>Buffer</code> 的内容的副本的 <code>Buffer</code>。</li>
<li><a href="#buffer_class_method_buffer_from_string_encoding"><code>Buffer.from(string[, encoding])</code></a> 返回一个新建的包含所提供的字符串的副本的 <code>Buffer</code>。</li>
<li>[<code>Buffer.alloc(size[, fill[, encoding]])</code>]<a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a> 返回一个指定大小的被填满的 <code>Buffer</code> 实例。
这个方法会明显地比 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> 慢，但可确保新创建的 <code>Buffer</code> 实例绝不会包含旧的和潜在的敏感数据。</li>
<li><a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> 与 <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow(size)</code></a> 返回一个新建的指定 <code>size</code> 的 <code>Buffer</code>，但它的内容<strong>必须</strong>被初始化，可以使用 <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> 或完全写满。</li>
</ul>
<p>如果 <code>size</code> 小于或等于 <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> 的一半，则 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 返回的 <code>Buffer</code> 实例<strong>可能</strong>会被分配进一个共享的内部内存池。</p>
<h3><code>--zero-fill-buffers</code> 命令行选项<span><a class="mark" href="#buffer_the_zero_fill_buffers_command_line_option" id="buffer_the_zero_fill_buffers_command_line_option">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.10.0</span>
</div><p>Node.js 可以在一开始就使用 <code>--zero-fill-buffers</code> 命令行选项强制所有使用 <code>new Buffer(size)</code> 、<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 、<a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> 或 <code>new SlowBuffer(size)</code> 新分配的 <code>Buffer</code> 实例在创建时<strong>自动用 0 填充</strong>。
使用这个选项会<strong>改变</strong>这些方法的<strong>默认行为</strong>，且<strong>对性能有明显的影响</strong>。
建议只在需要强制新分配的 <code>Buffer</code> 实例不能包含潜在的敏感数据时才使用 <code>--zero-fill-buffers</code> 选项。</p>
<p>例子：</p>
<pre><code class="lang-txt">$ node --zero-fill-buffers
&gt; Buffer.allocUnsafe(5);
&lt;Buffer 00 00 00 00 00&gt;
</code></pre>
<h3>是什么令 <code>Buffer.allocUnsafe()</code> 和 <code>Buffer.allocUnsafeSlow()</code> 不安全？<span><a class="mark" href="#buffer_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe" id="buffer_what_makes_buffer_allocunsafe_and_buffer_allocunsafeslow_unsafe">#</a></span></h3>
<p>当调用 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 和 <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> 时，被分配的内存段是<strong>未初始化的</strong>（没有用 0 填充）。
虽然这样的设计使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感旧数据。
使用通过 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 创建的没有被<strong>完全</strong>重写内存的 <code>Buffer</code> ，在 <code>Buffer</code> 内存可读的情况下，可能泄露它的旧数据。</p>
<p>虽然使用 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 有明显的性能优势，但必须额外<strong>小心</strong>，以避免给应用程序引入安全漏洞。</p>
<h2>Buffer 与字符编码<span><a class="mark" href="#buffer_buffers_and_character_encodings" id="buffer_buffers_and_character_encodings">#</a></span></h2>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.4.0</td>
<td><p>Introduced <code>latin1</code> as an alias for <code>binary</code>.</p>
</td></tr>
<tr><td>v5.0.0</td>
<td><p>Removed the deprecated <code>raw</code> and <code>raws</code> encodings.</p>
</td></tr>
</tbody></table>
</details>
</div><p><code>Buffer</code> 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。
通过使用显式的字符编码，就可以在 <code>Buffer</code> 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from(&apos;hello world&apos;, &apos;ascii&apos;);

// 输出 68656c6c6f20776f726c64
console.log(buf.toString(&apos;hex&apos;));

// 输出 aGVsbG8gd29ybGQ=
console.log(buf.toString(&apos;base64&apos;));
</code></pre>
<p>Node.js 目前支持的字符编码包括：</p>
<ul>
<li><p><code>&apos;ascii&apos;</code> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</p>
</li>
<li><p><code>&apos;utf8&apos;</code> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</p>
</li>
<li><p><code>&apos;utf16le&apos;</code> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</p>
</li>
<li><p><code>&apos;ucs2&apos;</code> - <code>&apos;utf16le&apos;</code> 的别名。</p>
</li>
<li><p><code>&apos;base64&apos;</code> - Base64 编码。当从字符串创建 <code>Buffer</code> 时，按照 <a href="javascript:;">RFC4648 第 5 章</a>的规定，这种编码也将正确地接受“URL 与文件名安全字母表”。</p>
</li>
<li><p><code>&apos;latin1&apos;</code> - 一种把 <code>Buffer</code> 编码成一字节编码的字符串的方式（由 IANA 定义在 <a href="javascript:;">RFC1345</a> 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）。</p>
</li>
<li><p><code>&apos;binary&apos;</code> - <code>&apos;latin1&apos;</code> 的别名。</p>
</li>
<li><p><code>&apos;hex&apos;</code> - 将每个字节编码为两个十六进制字符。</p>
</li>
</ul>
<p><strong>注意</strong>：现代浏览器遵循 <a href="javascript:;">WHATWG 编码标准</a> 将 &apos;latin1&apos; 和 ISO-8859-1 别名为 win-1252。
这意味着当进行例如 <code>http.get()</code> 这样的操作时，如果返回的字符编码是 WHATWG 规范列表中的，则有可能服务器真的返回 win-1252 编码的数据，此时使用 <code>&apos;latin1&apos;</code> 字符编码可能会错误地解码数据。</p>
<h2>Buffer 与 TypedArray<span><a class="mark" href="#buffer_buffers_and_typedarray" id="buffer_buffers_and_typedarray">#</a></span></h2>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v3.0.0</td>
<td><p>The <code>Buffer</code>s class now inherits from <code>Uint8Array</code>.</p>
</td></tr>
</tbody></table>
</details>
</div><p><code>Buffer</code> 实例也是 <a href="javascript:;"><code>Uint8Array</code></a> 实例。
但是与 <a href="javascript:;"><code>ECMAScript 2015</code></a> 中的 TypedArray 规范还是有些微妙的不同。
例如，当 <a href="javascript:;"><code>ArrayBuffer#slice()</code></a> 创建一个切片的副本时，<a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> 的实现是在现有的 <code>Buffer</code> 上不经过拷贝直接进行创建，这也使得 <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> 更高效。</p>
<p>遵循以下注意事项，也可以从一个 <code>Buffer</code> 创建一个新的 <a href="javascript:;"><code>TypedArray</code></a> 实例：</p>
<ol>
<li><p><code>Buffer</code> 对象的内存是拷贝到 <a href="javascript:;"><code>TypedArray</code></a> 的，而不是共享的。</p>
</li>
<li><p><code>Buffer</code> 对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组。
也就是说，<code>new Uint32Array(Buffer.from([1, 2, 3, 4]))</code> 会创建一个包含 <code>[1, 2, 3, 4]</code> 四个元素的 <a href="javascript:;"><code>Uint32Array</code></a>，而不是一个只包含一个元素 <code>[0x1020304]</code> 或 <code>[0x4030201]</code> 的 <a href="javascript:;"><code>Uint32Array</code></a> 。</p>
</li>
</ol>
<p>也可以通过 TypeArray 对象的 <code>.buffer</code> 属性创建一个新建的且与 <a href="javascript:;"><code>TypedArray</code></a> 实例共享同一分配内存的 <code>Buffer</code> 。</p>
<p>例子：</p>
<pre><code class="lang-js">const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// 拷贝 `arr` 的内容
const buf1 = Buffer.from(arr);

// 与 `arr` 共享内存
const buf2 = Buffer.from(arr.buffer);

// 输出: &lt;Buffer 88 a0&gt;
console.log(buf1);

// 输出: &lt;Buffer 88 13 a0 0f&gt;
console.log(buf2);

arr[1] = 6000;

// 输出: &lt;Buffer 88 a0&gt;
console.log(buf1);

// 输出: &lt;Buffer 88 13 70 17&gt;
console.log(buf2);
</code></pre>
<p>注意，当使用 <a href="javascript:;"><code>TypedArray</code></a> 的 <code>.buffer</code> 创建 <code>Buffer</code> 时，也可以通过传入 <code>byteOffset</code> 和 <code>length</code> 参数只使用 <a href="javascript:;"><code>ArrayBuffer</code></a> 的一部分。</p>
<p>例子：</p>
<pre><code class="lang-js">const arr = new Uint16Array(20);
const buf = Buffer.from(arr.buffer, 0, 16);

// 输出: 16
console.log(buf.length);
</code></pre>
<p><code>Buffer.from()</code> 和 <a href="javascript:;"><code>TypedArray.from()</code></a> 有着不同的签名与实现。
具体而言，<a href="javascript:;"><code>TypedArray</code></a> 的变种接受第二个参数，在类型数组的每个元素上调用一次映射函数：</p>
<ul>
<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>
</ul>
<p><code>Buffer.from()</code> 方法不支持使用映射函数：</p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a></li>
<li>[<code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code>]<a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_string_encoding"><code>Buffer.from(string[, encoding])</code></a></li>
</ul>
<h2>Buffer 与 ES6 迭代器<span><a class="mark" href="#buffer_buffers_and_es6_iteration" id="buffer_buffers_and_es6_iteration">#</a></span></h2>
<p><code>Buffer</code> 实例可以使用 <a href="javascript:;"><code>ECMAScript 2015</code></a> (ES6) 的 <code>for..of</code> 语法进行遍历。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3]);

// 输出:
//   1
//   2
//   3
for (const b of buf) {
  console.log(b);
}
</code></pre>
<p>此外，<a href="#buffer_buf_values"><code>buf.values()</code></a> 、<a href="#buffer_buf_keys"><code>buf.keys()</code></a> 和 <a href="#buffer_buf_entries"><code>buf.entries()</code></a> 方法可用于创建迭代器。</p>
<h2>Buffer 类<span><a class="mark" href="#buffer_class_buffer" id="buffer_class_buffer">#</a></span></h2>
<p><code>Buffer</code> 类是一个全局变量类型，用来直接处理二进制数据的。
它能够使用多种方式构建。</p>
<h3>new Buffer(array)<span><a class="mark" href="#buffer_new_buffer_array" id="buffer_new_buffer_array">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p>
</td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p>
</td></tr>
<tr><td>v6.0.0</td>
<td><p><span>废弃于: v6.0.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 废弃的: 使用 <a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> 代替。</div><ul>
<li><code>array</code> 
            <a href="javascript:;" class="type">&lt;integer[]&gt;</a> 要从中复制的字节数组。</li>
</ul>
<p>使用八字节的 <code>array</code> 分配一个新的 <code>Buffer</code>。</p>
<p>例子:</p>
<pre><code class="lang-js">// 创建一个新的包含字符串 &apos;buffer&apos; 的 UTF-8 编码的 Buffer
const buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
</code></pre>
<h3>new Buffer(arrayBuffer[, byteOffset [, length]])<span><a class="mark" href="#buffer_new_buffer_arraybuffer_byteoffset_length" id="buffer_new_buffer_arraybuffer_byteoffset_length">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p>
</td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p>
</td></tr>
<tr><td>v6.0.0</td>
<td><p>The <code>byteOffset</code> and <code>length</code> parameters are supported now.</p>
</td></tr>
<tr><td>v6.0.0</td>
<td><p><span>废弃于: v6.0.0</span></p>
</td></tr>
<tr><td>v3.0.0</td>
<td><p><span>新增于: v3.0.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 废弃的: 使用 [<code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code>]<a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer)</code></a> 代替。</div><ul>
<li><code>arrayBuffer</code> 
            <a href="javascript:;" class="type">&lt;ArrayBuffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;SharedArrayBuffer&gt;</a> <a href="javascript:;"><code>ArrayBuffer</code></a> 或 <a href="javascript:;"><code>SharedArrayBuffer</code></a> 或 <a href="javascript:;"><code>TypedArray</code></a> 的 <code>.buffer</code> 属性。</li>
<li><code>byteOffset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始拷贝的索引。 <strong>默认：</strong> <code>0</code>。</li>
<li><code>length</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 拷贝的字节数。<strong>默认：</strong> <code>arrayBuffer.length - byteOffset</code>。</li>
</ul>
<p>该方法将创建 <a href="javascript:;"><code>ArrayBuffer</code></a> 或 <a href="javascript:;"><code>SharedArrayBuffer</code></a> 的视图，而不会复制底层内存。例如，当传入一个 <a href="javascript:;"><code>TypedArray</code></a> 实例的 <code>.buffer</code> 属性的引用时，这个新建的 <code>Buffer</code> 会像 <a href="javascript:;"><code>TypedArray</code></a> 那样共享同一段分配的内存。</p>
<p>可选的 <code>byteOffset</code> 和 <code>length</code> 参数指定将与 <code>Buffer</code> 共享的 <code>arrayBuffer</code> 的内存范围。</p>
<p>例子:</p>
<pre><code class="lang-js">const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// 与 `arr` 共享内存
const buf = new Buffer(arr.buffer);

// 输出: &lt;Buffer 88 13 a0 0f&gt;
console.log(buf);

// 改变原始的 Uint16Array 也将改变 Buffer
arr[1] = 6000;

// 输出: &lt;Buffer 88 13 70 17&gt;
console.log(buf);
</code></pre>
<h3>new Buffer(buffer)<span><a class="mark" href="#buffer_new_buffer_buffer" id="buffer_new_buffer_buffer">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p>
</td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p>
</td></tr>
<tr><td>v6.0.0</td>
<td><p><span>废弃于: v6.0.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 废弃的: 使用 <a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> 代替。</div><ul>
<li><code>buffer</code> 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> 一个要拷贝数据的已存在的 <code>Buffer</code></li>
</ul>
<p>将传入的 <code>buffer</code> 数据拷贝到一个新建的 <code>Buffer</code> 实例。</p>
<p>例子:</p>
<pre><code class="lang-js">const buf1 = new Buffer(&apos;buffer&apos;);
const buf2 = new Buffer(buf1);

buf1[0] = 0x61;

// 输出: auffer
console.log(buf1.toString());

// Prints: buffer
console.log(buf2.toString());
</code></pre>
<h3>new Buffer(size)<span><a class="mark" href="#buffer_new_buffer_size" id="buffer_new_buffer_size">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>new Buffer(size) will return zero-filled memory by default.</p>
</td></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p>
</td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p>
</td></tr>
<tr><td>v6.0.0</td>
<td><p><span>废弃于: v6.0.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 废弃的: 使用 <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a> 代替（或 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>）。</div><ul>
<li><code>size</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 新建的 <code>Buffer</code> 期望的长度</li>
</ul>
<p>分配一个大小为 <code>size</code> 字节的新建的 <code>Buffer</code>。如果 <code>size</code> 大于 <a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> 或小于 0，则抛出 <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> 错误。如果 <code>size</code> 为 0，则创建一个长度为 0 的 <code>Buffer</code>。</p>
<p>在 Node.js 8.0.0 之前，以这种方式创建的 <code>Buffer</code> 实例的底层内存是 <em>未初始化</em> 的。新建的 <code>Buffer</code> 的内容是未知的并且 <em>可能包含敏感数据</em>。使用 <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc(size)</code></a> 代替它去初始化 <code>Buffer</code> 为 0。</p>
<p>例子:</p>
<pre><code class="lang-js">const buf = new Buffer(10);

// 输出: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;
console.log(buf);
</code></pre>
<h3>new Buffer(string[, encoding])<span><a class="mark" href="#buffer_new_buffer_string_encoding" id="buffer_new_buffer_string_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v7.2.1</td>
<td><p>Calling this constructor no longer emits a deprecation warning.</p>
</td></tr>
<tr><td>v7.0.0</td>
<td><p>Calling this constructor emits a deprecation warning now.</p>
</td></tr>
<tr><td>v6.0.0</td>
<td><p><span>废弃于: v6.0.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 废弃的: 使用 <a href="#buffer_class_method_buffer_from_string_encoding"><code>Buffer.from(string[, encoding])</code></a> 代替。</div><ul>
<li><code>string</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 要编码的字符串</li>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> <code>string</code> 的字符串编码。 <strong>默认：</strong> <code>&apos;utf8&apos;</code></li>
</ul>
<p>创建一个包含给定字符串 <code>string</code> 的 <code>Buffer</code>。<code>encoding</code> 参数制定 <code>string</code> 的字符串编码。</p>
<p>例子:</p>
<pre><code class="lang-js">const buf1 = new Buffer(&apos;this is a tést&apos;);

// 输出: this is a tést
console.log(buf1.toString());

// 输出: this is a tC)st
console.log(buf1.toString(&apos;ascii&apos;));


const buf2 = new Buffer(&apos;7468697320697320612074c3a97374&apos;, &apos;hex&apos;);

// 输出: this is a tést
console.log(buf2.toString());
</code></pre>
<h3>类方法：Buffer.alloc(size[, fill[, encoding]])<span><a class="mark" href="#buffer_class_method_buffer_alloc_size_fill_encoding" id="buffer_class_method_buffer_alloc_size_fill_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.9.3</td>
<td><p>Specifying an invalid string for <code>fill</code> now results in a zero-filled buffer.</p>
</td></tr>
<tr><td>v5.10.0</td>
<td><p><span>新增于: v5.10.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>size</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 新建的 <code>Buffer</code> 期望的长度</li>
<li><code>fill</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> | 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 用来预填充新建的 <code>Buffer</code> 的值。
<strong>默认:</strong> <code>0</code></li>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 如果 <code>fill</code> 是字符串，则该值是它的字符编码。
<strong>默认:</strong> <code>&apos;utf8&apos;</code></li>
</ul>
<p>分配一个大小为 <code>size</code> 字节的新建的 <code>Buffer</code> 。
如果 <code>fill</code> 为 <code>undefined</code> ，则该 <code>Buffer</code> 会用 <strong>0 填充</strong>。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.alloc(5);

// 输出: &lt;Buffer 00 00 00 00 00&gt;
console.log(buf);
</code></pre>
<p>分配一个大小为 <code>size</code> 字节的新建的 <code>Buffer</code> 。
如果 <code>size</code> 大于 <a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> 或小于 0，则抛出 <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> 错误。
如果 <code>size</code> 为 0，则创建一个长度为 0 的 <code>Buffer</code>。</p>
<p>如果指定了 <code>fill</code> ，则会调用 <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(fill)</code></a> 初始化分配的 <code>Buffer</code> 。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.alloc(5, &apos;a&apos;);

// 输出: &lt;Buffer 61 61 61 61 61&gt;
console.log(buf);
</code></pre>
<p>如果同时指定了 <code>fill</code> 和 <code>encoding</code> ，则会调用 <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(fill, encoding)</code></a> 初始化分配的 <code>Buffer</code> 。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.alloc(11, &apos;aGVsbG8gd29ybGQ=&apos;, &apos;base64&apos;);

// 输出: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;
console.log(buf);
</code></pre>
<p>调用 <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a> 会明显地比另一个方法 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 慢，但是能确保新建的 <code>Buffer</code> 实例的内容<strong>不会包含敏感数据</strong>。</p>
<p>如果 <code>size</code> 不是一个数值，则抛出 <code>TypeError</code> 错误。</p>
<h3>类方法：Buffer.allocUnsafe(size)<span><a class="mark" href="#buffer_class_method_buffer_allocunsafe_size" id="buffer_class_method_buffer_allocunsafe_size">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v7.0.0</td>
<td><p>Passing a negative <code>size</code> will now throw an error.</p>
</td></tr>
<tr><td>v5.10.0</td>
<td><p><span>新增于: v5.10.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>size</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 新建的 <code>Buffer</code> 期望的长度</li>
</ul>
<p>分配一个大小为 <code>size</code> 字节的新建的 <code>Buffer</code> 。
如果 <code>size</code> 大于 <a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> 或小于 0，则抛出 <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> 错误。
如果 <code>size</code> 为 0，则创建一个长度为 0 的 <code>Buffer</code>。</p>
<p>以这种方式创建的 <code>Buffer</code> 实例的底层内存是<strong>未初始化</strong>的。
新创建的 <code>Buffer</code> 的内容是未知的，且<strong>可能包含敏感数据</strong>。
可以使用 <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> 初始化 <code>Buffer</code> 实例为0。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(10);

// 输出: (内容可能不同): &lt;Buffer a0 8b 28 3f 01 00 00 00 50 32&gt;
console.log(buf);

buf.fill(0);

// 输出: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;
console.log(buf);
</code></pre>
<p>如果 <code>size</code> 不是一个数值，则抛出 <code>TypeError</code> 错误。</p>
<p>注意，<code>Buffer</code> 模块会预分配一个大小为 <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> 的内部 <code>Buffer</code> 实例作为快速分配池，
用于使用 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 新创建的 <code>Buffer</code> 实例，以及废弃的 <code>new Buffer(size)</code> 构造器，
仅限于当 <code>size</code> 小于或等于 <code>Buffer.poolSize &gt;&gt; 1</code> （<a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> 除以2后的最大整数值）。</p>
<p>对这个预分配的内部内存池的使用，是调用 <code>Buffer.alloc(size, fill)</code> 和 <code>Buffer.allocUnsafe(size).fill(fill)</code> 的关键区别。
具体地说，<code>Buffer.alloc(size, fill)</code> <strong>永远不会</strong>使用这个内部的 <code>Buffer</code> 池，但如果 <code>size</code> 小于或等于 <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> 的一半， <code>Buffer.allocUnsafe(size).fill(fill)</code> <strong>会</strong>使用这个内部的 <code>Buffer</code> 池。
当应用程序需要 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 提供额外的性能时，这个细微的区别是非常重要的。</p>
<h3>类方法：Buffer.allocUnsafeSlow(size)<span><a class="mark" href="#buffer_class_method_buffer_allocunsafeslow_size" id="buffer_class_method_buffer_allocunsafeslow_size">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.12.0</span>
</div><ul>
<li><code>size</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 新建的 <code>Buffer</code> 期望的长度</li>
</ul>
<p>分配一个大小为 <code>size</code> 字节的新建的 <code>Buffer</code> 。
如果 <code>size</code> 大于 <a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> 或小于 0，则抛出 <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> 错误。
如果 <code>size</code> 为 0，则创建一个长度为 0 的 <code>Buffer</code>。</p>
<p>以这种方式创建的 <code>Buffer</code> 实例的底层内存是<strong>未初始化</strong>的。
新创建的 <code>Buffer</code> 的内容是未知的，且<strong>可能包含敏感数据</strong>。
可以使用 <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> 初始化 <code>Buffer</code> 实例为0。</p>
<p>当使用 <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> 分配新建的 <code>Buffer</code> 时，当分配的内存小于 4KB 时，默认会从一个单一的预分配的 <code>Buffer</code> 切割出来。
这使得应用程序可以避免垃圾回收机制因创建太多独立分配的 <code>Buffer</code> 实例而过度使用。
这个方法通过像大多数持久对象一样消除追踪与清理的需求，改善了性能与内存使用。</p>
<p>当然，在开发者可能需要在不确定的时间段从内存池保留一小块内存的情况下，使用 <code>Buffer.allocUnsafeSlow()</code> 创建一个非池的 <code>Buffer</code> 实例然后拷贝出相关的位元是合适的做法。</p>
<p>例子：</p>
<pre><code class="lang-js">// 需要保留一小块内存块
const store = [];

socket.on(&apos;readable&apos;, () =&gt; {
  const data = socket.read();

  // 为保留的数据分配内存
  const sb = Buffer.allocUnsafeSlow(10);

  // 拷贝数据进新分配的内存
  data.copy(sb, 0, 0, 10);

  store.push(sb);
});
</code></pre>
<p><code>Buffer.allocUnsafeSlow()</code> 应当仅仅作为开发者已经在他们的应用程序中观察到过度的内存保留之后的终极手段使用。</p>
<p>如果 <code>size</code> 不是一个数值，则抛出 <code>TypeError</code> 错误。</p>
<h3>类方法：Buffer.byteLength(string[, encoding])<span><a class="mark" href="#buffer_class_method_buffer_bytelength_string_encoding" id="buffer_class_method_buffer_bytelength_string_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v7.0.0</td>
<td><p>Passing invalid input will now throw an error.</p>
</td></tr>
<tr><td>v5.10.0</td>
<td><p>The <code>string</code> parameter can now be any <code>TypedArray</code>, <code>DataView</code> or <code>ArrayBuffer</code>.</p>
</td></tr>
<tr><td>v0.1.90</td>
<td><p><span>新增于: v0.1.90</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>string</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> | 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;TypedArray&gt;</a> | 
            <a href="javascript:;" class="type">&lt;DataView&gt;</a> | 
            <a href="javascript:;" class="type">&lt;ArrayBuffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;SharedArrayBuffer&gt;</a> 要计算长度的值</li>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 如果 <code>string</code> 是字符串，则这是它的字符编码。
<strong>默认:</strong> <code>&apos;utf8&apos;</code></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>string</code> 包含的字节数</li>
</ul>
<p>返回一个字符串的实际字节长度。
这与 <a href="javascript:;"><code>String.prototype.length</code></a> 不同，因为那返回字符串的<strong>字符</strong>数。</p>
<p><em>注意</em> 对于 <code>&apos;base64&apos;</code> 和 <code>&apos;hex&apos;</code>， 该函数假定有效的输入。 对于包含 non-Base64/Hex-encoded 数据的字符串 (e.g. 空格)， 返回值可能大于
从字符串中创建的 <code>Buffer</code> 的长度。 </p>
<p>例子：</p>
<pre><code class="lang-js">const str = &apos;\u00bd + \u00bc = \u00be&apos;;

// 输出: ½ + ¼ = ¾: 9 个字符, 12 个字节
console.log(`${str}: ${str.length} 个字符, ` +
            `${Buffer.byteLength(str, &apos;utf8&apos;)} 个字节`);
</code></pre>
<p>当 <code>string</code> 是一个 <code>Buffer</code>/<a href="javascript:;"><code>DataView</code></a>/<a href="javascript:;"><code>TypedArray</code></a>/<a href="javascript:;"><code>ArrayBuffer</code></a>/<a href="javascript:;"><code>SharedArrayBuffer</code></a> 时，返回实际的字节长度。</p>
<h3>类方法：Buffer.compare(buf1, buf2)<span><a class="mark" href="#buffer_class_method_buffer_compare_buf1_buf2" id="buffer_class_method_buffer_compare_buf1_buf2">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The arguments can now be <code>Uint8Array</code>s.</p>
</td></tr>
<tr><td>v0.11.13</td>
<td><p><span>新增于: v0.11.13</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>buf1</code> 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;Uint8Array&gt;</a></li>
<li><code>buf2</code> 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;Uint8Array&gt;</a></li>
<li>Returns: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>比较 <code>buf1</code> 和 <code>buf2</code> ，通常用于 <code>Buffer</code> 实例数组的排序。
相当于调用 <a href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend"><code>buf1.compare(buf2)</code></a> 。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&apos;1234&apos;);
const buf2 = Buffer.from(&apos;0123&apos;);
const arr = [buf1, buf2];

// 输出: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]
// (结果相当于: [buf2, buf1])
console.log(arr.sort(Buffer.compare));
</code></pre>
<h3>类方法：Buffer.concat(list[, totalLength])<span><a class="mark" href="#buffer_class_method_buffer_concat_list_totallength" id="buffer_class_method_buffer_concat_list_totallength">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The elements of <code>list</code> can now be <code>Uint8Array</code>s.</p>
</td></tr>
<tr><td>v0.7.11</td>
<td><p><span>新增于: v0.7.11</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>list</code> 
            <a href="javascript:;" class="type">&lt;Array&gt;</a> 要合并的 <code>Buffer</code> 或 <a href="javascript:;"><code>Uint8Array</code></a> 实例的数组</li>
<li><code>totalLength</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 合并时 <code>list</code> 中 <code>Buffer</code> 实例的总长度</li>
<li>返回: 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>返回一个合并了 <code>list</code> 中所有 <code>Buffer</code> 实例的新建的 <code>Buffer</code> 。</p>
<p>如果 <code>list</code> 中没有元素、或 <code>totalLength</code> 为 0 ，则返回一个新建的长度为 0 的 <code>Buffer</code> 。</p>
<p>如果没有提供 <code>totalLength</code> ，则从 <code>list</code> 中的 <code>Buffer</code> 实例计算得到。
为了计算 <code>totalLength</code> 会导致需要执行额外的循环，所以提供明确的长度会运行更快。</p>
<p>如果提供了 <code>totalLength</code>，<code>totalLength</code> 必须是一个正整数。如果从 <code>list</code> 中计算得到的 <code>Buffer</code> 长度超过了 <code>totalLength</code>，则合并的结果将会被截断为 <code>totalLength</code> 的长度。</p>
<p>例子：从一个包含三个 <code>Buffer</code> 实例的数组创建为一个单一的 <code>Buffer</code>。</p>
<pre><code class="lang-js">const buf1 = Buffer.alloc(10);
const buf2 = Buffer.alloc(14);
const buf3 = Buffer.alloc(18);
const totalLength = buf1.length + buf2.length + buf3.length;

// 输出: 42
console.log(totalLength);

const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);

// 输出: &lt;Buffer 00 00 00 00 ...&gt;
console.log(bufA);

// 输出: 42
console.log(bufA.length);
</code></pre>
<h3>类方法：Buffer.from(array)<span><a class="mark" href="#buffer_class_method_buffer_from_array" id="buffer_class_method_buffer_from_array">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.10.0</span>
</div><ul>
<li><code>array</code> 
            <a href="javascript:;" class="type">&lt;Array&gt;</a></li>
</ul>
<p>通过一个八位字节的 <code>array</code> 创建一个新的 <code>Buffer</code> 。</p>
<p>例子：</p>
<pre><code class="lang-js">// 创建一个新的包含字符串 &apos;buffer&apos; 的 UTF-8 字节的 Buffer
const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
</code></pre>
<p>如果 <code>array</code> 不是一个数组，则抛出 <code>TypeError</code> 错误。</p>
<h3>类方法：Buffer.from(arrayBuffer[, byteOffset[, length]])<span><a class="mark" href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length" id="buffer_class_method_buffer_from_arraybuffer_byteoffset_length">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.10.0</span>
</div><ul>
<li><code>arrayBuffer</code> 
            <a href="javascript:;" class="type">&lt;ArrayBuffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;SharedArrayBuffer&gt;</a> <a href="javascript:;"><code>ArrayBuffer</code></a> 或 <a href="javascript:;"><code>SharedArrayBuffer</code></a> 或 <a href="javascript:;"><code>TypedArray</code></a> 的 <code>.buffer</code> 属性。</li>
<li><code>byteOffset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始拷贝的索引。默认为 <code>0</code>。</li>
<li><code>length</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 拷贝的字节数。默认为 <code>arrayBuffer.length - byteOffset</code>。</li>
</ul>
<p>该方法将创建一个 <a href="javascript:;"><code>ArrayBuffer</code></a> 的视图，而不会复制底层内存。例如，当传入一个 <a href="javascript:;"><code>TypedArray</code></a> 实例的 <code>.buffer</code> 属性的引用时，这个新建的 <code>Buffer</code> 会像 <a href="javascript:;"><code>TypedArray</code></a> 那样共享同一分配的内存。</p>
<p>例子：</p>
<pre><code class="lang-js">const arr = new Uint16Array(2);

arr[0] = 5000;
arr[1] = 4000;

// 与 `arr` 共享内存
const buf = Buffer.from(arr.buffer);

// 输出: &lt;Buffer 88 13 a0 0f&gt;
console.log(buf);

// 改变原始的 Uint16Array 也会改变 Buffer
arr[1] = 6000;

// 输出: &lt;Buffer 88 13 70 17&gt;
console.log(buf);
</code></pre>
<p>可选的 <code>byteOffset</code> 和 <code>length</code> 参数指定将与 <code>Buffer</code> 共享的 <code>arrayBuffer</code> 的内存范围。</p>
<p>例子：</p>
<pre><code class="lang-js">const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);

// 输出: 2
console.log(buf.length);
</code></pre>
<p>如果 <code>arrayBuffer</code> 不是 <a href="javascript:;"><code>ArrayBuffer</code></a> 或 <a href="javascript:;"><code>SharedArrayBuffer</code></a>，则抛出 <code>TypeError</code> 错误。</p>
<h3>类方法：Buffer.from(buffer)<span><a class="mark" href="#buffer_class_method_buffer_from_buffer" id="buffer_class_method_buffer_from_buffer">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.10.0</span>
</div><ul>
<li><code>buffer</code> 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> 一个要拷贝数据的已存在的 <code>Buffer</code></li>
</ul>
<p>将传入的 <code>buffer</code> 数据拷贝到一个新建的 <code>Buffer</code> 实例。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&apos;buffer&apos;);
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;

// 输出: auffer
console.log(buf1.toString());

// 输出: buffer
console.log(buf2.toString());
</code></pre>
<p>如果 <code>buffer</code> 不是一个 <code>Buffer</code>，则抛出 <code>TypeError</code> 错误。</p>
<h3>类方法：Buffer.from(string[, encoding])<span><a class="mark" href="#buffer_class_method_buffer_from_string_encoding" id="buffer_class_method_buffer_from_string_encoding">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.10.0</span>
</div><ul>
<li><code>string</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 要编码的字符串</li>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> <code>string</code> 的字符编码。 <strong>默认:</strong> <code>&apos;utf8&apos;</code></li>
</ul>
<p>新建一个包含所给的 JavaScript 字符串 <code>string</code> 的 <code>Buffer</code> 。
<code>encoding</code> 参数指定 <code>string</code> 的字符编码。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&apos;this is a tést&apos;);

// 输出: this is a tést
console.log(buf1.toString());

// 输出: this is a tC)st
console.log(buf1.toString(&apos;ascii&apos;));


const buf2 = Buffer.from(&apos;7468697320697320612074c3a97374&apos;, &apos;hex&apos;);

// 输出: this is a tést
console.log(buf2.toString());
</code></pre>
<p>如果 <code>string</code> 不是一个字符串，则抛出 <code>TypeError</code> 错误。</p>
<h3>Class Method: Buffer.from(object[, offsetOrEncoding[, length]])<span><a class="mark" href="#buffer_class_method_buffer_from_object_offsetorencoding_length" id="buffer_class_method_buffer_from_object_offsetorencoding_length">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v8.2.0</span>
</div><ul>
<li><code>object</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a> 一个支持 <code>Symbol.toPrimitive</code> 或 <code>valueOf()</code> 的对象</li>
<li><code>offsetOrEncoding</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> | 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 字节偏移量或编码，取决于 <code>object.valueOf()</code> 或 <code>object[Symbol.toPrimitive]()</code> 的返回值。</li>
<li><code>length</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> 长度值，取决于 <code>object.valueOf()</code> 或 <code>object[Symbol.toPrimitive]()</code> 的返回值。</li>
</ul>
<p>那些其 <code>valueOf()</code> 方法返回值如果不严格等于 <code>object</code> 的对象，返回<code>Buffer.from(object.valueOf(), offsetOrEncoding, length)</code>。</p>
<p>例子:</p>
<pre><code class="lang-js">const buf = Buffer.from(new String(&apos;this is a test&apos;));
// &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;
</code></pre>
<p>那些支持 <code>Symbol.toPrimitive</code> 的对象， 返回 <code>Buffer.from(object[Symbol.toPrimitive](), offsetOrEncoding, length)</code>。</p>
<p>例子:</p>
<pre><code class="lang-js">class Foo {
  [Symbol.toPrimitive]() {
    return &apos;this is a test&apos;;
  }
}

const buf = Buffer.from(new Foo(), &apos;utf8&apos;);
// &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;
</code></pre>
<h3>类方法：Buffer.isBuffer(obj)<span><a class="mark" href="#buffer_class_method_buffer_isbuffer_obj" id="buffer_class_method_buffer_isbuffer_obj">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.101</span>
</div><ul>
<li><code>obj</code> 
            <a href="javascript:;" class="type">&lt;Object&gt;</a></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果 <code>obj</code> 是一个 <code>Buffer</code> 则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<h3>类方法：Buffer.isEncoding(encoding)<span><a class="mark" href="#buffer_class_method_buffer_isencoding_encoding" id="buffer_class_method_buffer_isencoding_encoding">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div><ul>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 一个要检查的字符编码名称</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果 <code>encoding</code> 是一个支持的字符编码则返回 <code>true</code>，否则返回 <code>false</code> 。</p>
<h3>类属性：Buffer.poolSize<span><a class="mark" href="#buffer_class_property_buffer_poolsize" id="buffer_class_property_buffer_poolsize">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.11.3</span>
</div><ul>
<li>
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <strong>默认:</strong> <code>8192</code></li>
</ul>
<p>这是用于决定预分配的、内部 <code>Buffer</code> 实例池的大小的字节数。
这个值可以修改。</p>
<h3>buf[index]<span><a class="mark" href="#buffer_buf_index" id="buffer_buf_index">#</a></span></h3>
<div class="api_metadata">

</div><p>索引操作符 <code>[index]</code> 可用于获取或设置 <code>buf</code> 中指定 <code>index</code> 位置的八位字节。
这个值指向的是单个字节，所以合法的值范围是的 <code>0x00</code> 至 <code>0xFF</code>（十六进制），或 <code>0</code> 至 <code>255</code>（十进制）。</p>
<p>该操作符继承自 <code>Uint8Array</code>，所以它对越界访问的处理与 <code>UInt8Array</code> 相同（也就是说，获取时返回 <code>undefined</code>，设置时什么也不做）。</p>
<p>例如：拷贝一个 ASCII 字符串到一个 <code>Buffer</code>，每次一个字节。</p>
<pre><code class="lang-js">const str = &apos;Node.js&apos;;
const buf = Buffer.allocUnsafe(str.length);

for (let i = 0; i &lt; str.length; i++) {
  buf[i] = str.charCodeAt(i);
}

// 输出: Node.js
console.log(buf.toString(&apos;ascii&apos;));
</code></pre>
<h3>buf.buffer<span><a class="mark" href="#buffer_buf_buffer" id="buffer_buf_buffer">#</a></span></h3>
<p><code>buffer</code> 属性指向创建该 <code>Buffer</code> 的底层的 <code>ArrayBuffer</code> 对象。</p>
<pre><code class="lang-js">const arrayBuffer = new ArrayBuffer(16);
const buffer = Buffer.from(arrayBuffer);

console.log(buffer.buffer === arrayBuffer);
// 输出: true
</code></pre>
<h3>buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])<span><a class="mark" href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend" id="buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>target</code> parameter can now be a <code>Uint8Array</code>.</p>
</td></tr>
<tr><td>v5.11.0</td>
<td><p>Additional parameters for specifying offsets are supported now.</p>
</td></tr>
<tr><td>v0.11.13</td>
<td><p><span>新增于: v0.11.13</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>target</code> 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;Uint8Array&gt;</a> 要比较的 <code>Buffer</code> 或 <a href="javascript:;"><code>Uint8Array</code></a>。</li>
<li><code>targetStart</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>target</code> 中开始对比的偏移量。
<strong>默认:</strong> <code>0</code></li>
<li><code>targetEnd</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>target</code> 中结束对比的偏移量（不包含）。
<strong>默认:</strong> <code>target.length</code></li>
<li><code>sourceStart</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>buf</code> 中开始对比的偏移量。
<strong>默认:</strong> <code>0</code></li>
<li><code>sourceEnd</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>buf</code> 中结束对比的偏移量（不包含）。
<strong>默认:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>比较 <code>buf</code> 与 <code>target</code>，返回表明 <code>buf</code> 在排序上是否排在 <code>target</code> 之前、或之后、或相同。
对比是基于各自 <code>Buffer</code> 实际的字节序列。</p>
<ul>
<li>如果 <code>target</code> 与 <code>buf</code> 相同，则返回 <code>0</code> 。</li>
<li>如果 <code>target</code> 排在 <code>buf</code> <strong>前面</strong>，则返回 <code>1</code> 。</li>
<li>如果 <code>target</code> 排在 <code>buf</code> <strong>后面</strong>，则返回 <code>-1</code> 。</li>
</ul>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&apos;ABC&apos;);
const buf2 = Buffer.from(&apos;BCD&apos;);
const buf3 = Buffer.from(&apos;ABCD&apos;);

// 输出: 0
console.log(buf1.compare(buf1));

// 输出: -1
console.log(buf1.compare(buf2));

// 输出: -1
console.log(buf1.compare(buf3));

// 输出: 1
console.log(buf2.compare(buf1));

// 输出: 1
console.log(buf2.compare(buf3));

// 输出: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]
// (结果相当于: [buf1, buf3, buf2])
console.log([buf1, buf2, buf3].sort(Buffer.compare));
</code></pre>
<p>可选的  <code>targetStart</code> 、 <code>targetEnd</code> 、 <code>sourceStart</code> 与 <code>sourceEnd</code> 参数可用于分别在 <code>target</code> 与 <code>buf</code> 中限制对比在指定的范围内。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);

// 输出: 0
console.log(buf1.compare(buf2, 5, 9, 0, 4));

// 输出: -1
console.log(buf1.compare(buf2, 0, 6, 4));

// 输出: 1
console.log(buf1.compare(buf2, 5, 6, 5));
</code></pre>
<p>如果 <code>targetStart &lt; 0</code> 、 <code>sourceStart &lt; 0</code> 、 <code>targetEnd &gt; target.byteLength</code> 或 <code>sourceEnd &gt; source.byteLength</code>，则抛出 <code>RangeError</code> 错误。</p>
<h3>buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])<span><a class="mark" href="#buffer_buf_copy_target_targetstart_sourcestart_sourceend" id="buffer_buf_copy_target_targetstart_sourcestart_sourceend">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>target</code> 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;Uint8Array&gt;</a> 要拷贝进的 <code>Buffer</code> 或 <a href="javascript:;"><code>Uint8Array</code></a>。</li>
<li><code>targetStart</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>target</code> 中开始拷贝进的偏移量。
<strong>默认:</strong> <code>0</code></li>
<li><code>sourceStart</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>buf</code> 中开始拷贝的偏移量。
<strong>默认:</strong> <code>0</code></li>
<li><code>sourceEnd</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>buf</code> 中结束拷贝的偏移量（不包含）。
<strong>默认:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 被拷贝的字节数。</li>
</ul>
<p>拷贝 <code>buf</code> 的一个区域的数据到 <code>target</code> 的一个区域，即便 <code>target</code> 的内存区域与 <code>buf</code> 的重叠。</p>
<p>例子：创建两个 <code>Buffer</code> 实例 <code>buf1</code> 与 <code>buf2</code> ，并拷贝 <code>buf1</code> 中第 16 个至第 19 个字节到 <code>buf2</code> 第 8 个字节起。</p>
<pre><code class="lang-js">const buf1 = Buffer.allocUnsafe(26);
const buf2 = Buffer.allocUnsafe(26).fill(&apos;!&apos;);

for (let i = 0; i &lt; 26; i++) {
  // 97 是 &apos;a&apos; 的十进制 ASCII 值
  buf1[i] = i + 97;
}

buf1.copy(buf2, 8, 16, 20);

// 输出: !!!!!!!!qrst!!!!!!!!!!!!!
console.log(buf2.toString(&apos;ascii&apos;, 0, 25));
</code></pre>
<p>例子：创建一个 <code>Buffer</code> ，并拷贝同一 <code>Buffer</code> 中一个区域的数据到另一个重叠的区域。</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 是 &apos;a&apos; 的十进制 ASCII 值
  buf[i] = i + 97;
}

buf.copy(buf, 0, 4, 10);

// 输出: efghijghijklmnopqrstuvwxyz
console.log(buf.toString());
</code></pre>
<h3>buf.entries()<span><a class="mark" href="#buffer_buf_entries" id="buffer_buf_entries">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v1.1.0</span>
</div><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;Iterator&gt;</a></li>
</ul>
<p>从 <code>buf</code> 的内容中，创建并返回一个 <code>[index, byte]</code> 形式的<a href="javascript:;">迭代器</a>。</p>
<p>例子：记录一个 <code>Buffer</code> 全部的内容。</p>
<pre><code class="lang-js">const buf = Buffer.from(&apos;buffer&apos;);

// 输出:
//   [0, 98]
//   [1, 117]
//   [2, 102]
//   [3, 102]
//   [4, 101]
//   [5, 114]
for (const pair of buf.entries()) {
  console.log(pair);
}
</code></pre>
<h3>buf.equals(otherBuffer)<span><a class="mark" href="#buffer_buf_equals_otherbuffer" id="buffer_buf_equals_otherbuffer">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The arguments can now be <code>Uint8Array</code>s.</p>
</td></tr>
<tr><td>v0.11.13</td>
<td><p><span>新增于: v0.11.13</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>otherBuffer</code> 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> 要比较的 <code>Buffer</code> 或 <a href="javascript:;"><code>Uint8Array</code></a>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果 <code>buf</code> 与 <code>otherBuffer</code> 具有完全相同的字节，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.from(&apos;ABC&apos;);
const buf2 = Buffer.from(&apos;414243&apos;, &apos;hex&apos;);
const buf3 = Buffer.from(&apos;ABCD&apos;);

// 输出: true
console.log(buf1.equals(buf2));

// 输出: false
console.log(buf1.equals(buf3));
</code></pre>
<h3>buf.fill(value[, offset[, end]][, encoding])<span><a class="mark" href="#buffer_buf_fill_value_offset_end_encoding" id="buffer_buf_fill_value_offset_end_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v5.7.0</td>
<td><p>The <code>encoding</code> parameter is supported now.</p>
</td></tr>
<tr><td>v0.5.0</td>
<td><p><span>新增于: v0.5.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> | 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 用来填充 <code>buf</code> 的值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始填充 <code>buf</code> 前要跳过的字节数。<strong>默认:</strong> <code>0</code>。</li>
<li><code>end</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 结束填充 <code>buf</code> 的位置（不包含）。<strong>默认:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a>。</li>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 如果 <code>value</code> 是一个字符串，则这是它的字符编码。<strong>默认:</strong> <code>&apos;utf8&apos;</code>。</li>
<li>返回: 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> <code>buf</code> 的引用。</li>
</ul>
<p>如果未指定 <code>offset</code> 和 <code>end</code>，则填充整个 <code>buf</code>。
这个简化使得一个 <code>Buffer</code> 的创建与填充可以在一行内完成。</p>
<p>例子：用 ASCII 字符 <code>&apos;h&apos;</code> 填充 <code>Buffer</code>。</p>
<pre><code class="lang-js">const b = Buffer.allocUnsafe(50).fill(&apos;h&apos;);

// 输出: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
console.log(b.toString());
</code></pre>
<p><code>value</code> 如果不是一个字符串或整数，则会被强行转换为 <code>uint32</code> 值。</p>
<p>如果 <code>fill()</code> 操作的最后一次写入的是一个多字节字符，则只有字符中适合 <code>buf</code> 的第一个字节会被写入。</p>
<p>例子：用一个两个字节的字符填充 <code>Buffer</code>。</p>
<pre><code class="lang-js">// 输出: &lt;Buffer c8 a2 c8&gt;
console.log(Buffer.allocUnsafe(3).fill(&apos;\u0222&apos;));
</code></pre>
<p>If <code>value</code> contains invalid characters, it is truncated; if no valid
fill data remains, no filling is performed:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(5);
// Prints: &lt;Buffer 61 61 61 61 61&gt;
console.log(buf.fill(&apos;a&apos;));
// Prints: &lt;Buffer aa aa aa aa aa&gt;
console.log(buf.fill(&apos;aazz&apos;, &apos;hex&apos;));
// Prints: &lt;Buffer aa aa aa aa aa&gt;
console.log(buf.fill(&apos;zz&apos;, &apos;hex&apos;));
</code></pre>
<h3>buf.includes(value[, byteOffset][, encoding])<span><a class="mark" href="#buffer_buf_includes_value_byteoffset_encoding" id="buffer_buf_includes_value_byteoffset_encoding">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.3.0</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> | 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要搜索的值</li>
<li><code>byteOffset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>buf</code> 中开始搜索的位置。<strong>默认:</strong> <code>0</code></li>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 如果 <code>value</code> 是一个字符串，则这是它的字符编码。
<strong>默认:</strong> <code>&apos;utf8&apos;</code></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 如果 <code>buf</code> 找到 <code>value</code>，则返回 <code>true</code>，否则返回 <code>false</code></li>
</ul>
<p>相当于 <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf() !== -1</code></a>。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from(&apos;this is a buffer&apos;);

// 输出: true
console.log(buf.includes(&apos;this&apos;));

// 输出: true
console.log(buf.includes(&apos;is&apos;));

// 输出: true
console.log(buf.includes(Buffer.from(&apos;a buffer&apos;)));

// 输出: true
// (97 是 &apos;a&apos; 的十进制 ASCII 值)
console.log(buf.includes(97));

// 输出: false
console.log(buf.includes(Buffer.from(&apos;a buffer example&apos;)));

// 输出: true
console.log(buf.includes(Buffer.from(&apos;a buffer example&apos;).slice(0, 8)));

// 输出: false
console.log(buf.includes(&apos;this&apos;, 4));
</code></pre>
<h3>buf.indexOf(value[, byteOffset][, encoding])<span><a class="mark" href="#buffer_buf_indexof_value_byteoffset_encoding" id="buffer_buf_indexof_value_byteoffset_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>value</code> can now be a <code>Uint8Array</code>.</p>
</td></tr>
<tr><td>v5.7.0, v4.4.0</td>
<td><p>When <code>encoding</code> is being passed, the <code>byteOffset</code> parameter is no longer required.</p>
</td></tr>
<tr><td>v1.5.0</td>
<td><p><span>新增于: v1.5.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> | 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;Uint8Array&gt;</a> | 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要搜索的值</li>
<li><code>byteOffset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>buf</code> 中开始搜索的位置。<strong>默认:</strong> <code>0</code></li>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 如果 <code>value</code> 是一个字符串，则这是它的字符编码。
<strong>默认:</strong> <code>&apos;utf8&apos;</code></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>buf</code> 中 <code>value</code> 首次出现的索引，如果 <code>buf</code> 没包含 <code>value</code> 则返回 <code>-1</code></li>
</ul>
<p>如果 <code>value</code> 是：</p>
<ul>
<li>字符串，则 <code>value</code> 根据 <code>encoding</code> 的字符编码进行解析。</li>
<li><code>Buffer</code> 或 <a href="javascript:;"><code>Uint8Array</code></a>，则 <code>value</code> 会被作为一个整体使用。如果要比较部分 <code>Buffer</code>，可使用 <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a>。</li>
<li>数值, 则 <code>value</code> 会解析为一个 <code>0</code> 至 <code>255</code> 之间的无符号八位整数值。</li>
</ul>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from(&apos;this is a buffer&apos;);

// 输出: 0
console.log(buf.indexOf(&apos;this&apos;));

// 输出: 2
console.log(buf.indexOf(&apos;is&apos;));

// 输出: 8
console.log(buf.indexOf(Buffer.from(&apos;a buffer&apos;)));

// 输出: 8
// (97 是 &apos;a&apos; 的十进制 ASCII 值)
console.log(buf.indexOf(97));

// 输出: -1
console.log(buf.indexOf(Buffer.from(&apos;a buffer example&apos;)));

// 输出: 8
console.log(buf.indexOf(Buffer.from(&apos;a buffer example&apos;).slice(0, 8)));


const utf16Buffer = Buffer.from(&apos;\u039a\u0391\u03a3\u03a3\u0395&apos;, &apos;ucs2&apos;);

// 输出: 4
console.log(utf16Buffer.indexOf(&apos;\u03a3&apos;, 0, &apos;ucs2&apos;));

// 输出: 6
console.log(utf16Buffer.indexOf(&apos;\u03a3&apos;, -4, &apos;ucs2&apos;));
</code></pre>
<p>如果 <code>value</code> 不是一个字符串， 数字， 或者 <code>Buffer</code>， 该方法会抛出一个
<code>TypeError</code> 异常， 如果 <code>value</code> 是一个数字， 它将会被强制转换成一个有效的 byte 值，
该值介于0到255之间。</p>
<p>如果 <code>byteOffset</code> 不是一个数字， 它将会被强制转换成一个数字。  任何对 <code>NaN</code> 或者 0, 像 <code>{}</code>, <code>[]</code>, <code>null</code> or <code>undefined</code>，
的参数， 将会搜索整个 buffer。 该行为和 <a href="javascript:;"><code>String#indexOf()</code></a> 保持一致。</p>
<pre><code class="lang-js">const b = Buffer.from(&apos;abcdef&apos;);

// 传入一个不是有效字节的数字
// 输出：2，相当于搜索 99 或 &apos;c&apos;
console.log(b.indexOf(99.9));
console.log(b.indexOf(256 + 99));

// 传入 byteOffset，其值强制转换为 NaN 或 0
// 输出：1，搜索整个 buffer
console.log(b.indexOf(&apos;b&apos;, undefined));
console.log(b.indexOf(&apos;b&apos;, {}));
console.log(b.indexOf(&apos;b&apos;, null));
console.log(b.indexOf(&apos;b&apos;, []));
</code></pre>
<p>如果 <code>value</code> 是一个空字符串或空 <code>Buffer</code>，并且 <code>byteOffset</code> 小于 <code>buf.length</code>，返回 <code>byteOffset</code>。如果 <code>value</code> 是一个空字符串，并且 <code>byteOffset</code> 大于 <code>buf.length</code>，返回 <code>buf.length</code>。</p>
<h3>buf.keys()<span><a class="mark" href="#buffer_buf_keys" id="buffer_buf_keys">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v1.1.0</span>
</div><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;Iterator&gt;</a></li>
</ul>
<p>创建并返回一个包含 <code>buf</code> 键名（索引）的<a href="javascript:;">迭代器</a>。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from(&apos;buffer&apos;);

// 输出:
//   0
//   1
//   2
//   3
//   4
//   5
for (const key of buf.keys()) {
  console.log(key);
}
</code></pre>
<h3>buf.lastIndexOf(value[, byteOffset][, encoding])<span><a class="mark" href="#buffer_buf_lastindexof_value_byteoffset_encoding" id="buffer_buf_lastindexof_value_byteoffset_encoding">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>value</code> can now be a <code>Uint8Array</code>.</p>
</td></tr>
<tr><td>v6.0.0</td>
<td><p><span>新增于: v6.0.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> | 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;Uint8Array&gt;</a> | 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要搜索的值</li>
<li><code>byteOffset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>buf</code> 中开始搜索的位置。
<strong>默认:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a><code>- 1</code></li>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 如果 <code>value</code> 是一个字符串，则这是它的字符编码。
<strong>默认:</strong> <code>&apos;utf8&apos;</code></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>buf</code> 中 <code>value</code> 最后一次出现的索引，如果 <code>buf</code> 没包含 <code>value</code> 则返回 <code>-1</code></li>
</ul>
<p>与 <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf()</code></a> 类似，除了 <code>buf</code> 是从后往前搜索而不是从前往后。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from(&apos;this buffer is a buffer&apos;);

// 输出: 0
console.log(buf.lastIndexOf(&apos;this&apos;));

// 输出: 17
console.log(buf.lastIndexOf(&apos;buffer&apos;));

// 输出: 17
console.log(buf.lastIndexOf(Buffer.from(&apos;buffer&apos;)));

// 输出: 15
// (97 是 &apos;a&apos; 的十进制 ASCII 值)
console.log(buf.lastIndexOf(97));

// 输出: -1
console.log(buf.lastIndexOf(Buffer.from(&apos;yolo&apos;)));

// 输出: 5
console.log(buf.lastIndexOf(&apos;buffer&apos;, 5));

// 输出: -1
console.log(buf.lastIndexOf(&apos;buffer&apos;, 4));


const utf16Buffer = Buffer.from(&apos;\u039a\u0391\u03a3\u03a3\u0395&apos;, &apos;ucs2&apos;);

// 输出: 6
console.log(utf16Buffer.lastIndexOf(&apos;\u03a3&apos;, undefined, &apos;ucs2&apos;));

// 输出: 4
console.log(utf16Buffer.lastIndexOf(&apos;\u03a3&apos;, -5, &apos;ucs2&apos;));
</code></pre>
<p>如果 <code>value</code> 不是一个字符串， 数字， 或者 <code>Buffer</code>， 该方法会抛出一个
<code>TypeError</code> 异常， 如果 <code>value</code> 是一个数字， 它将会被强制转换成一个有效的 byte 值，
该值介于0到255之间。</p>
<p>如果 <code>byteOffset</code> 不是一个数字， 它将会被强制转换成一个数字。  任何对 <code>NaN</code> or 0, like <code>{}</code>, <code>[]</code>, <code>null</code> or <code>undefined</code>，
的参数， 将会搜索整个 buffer。 该行为和 <a href="javascript:;"><code>String#lastIndexOf()</code></a> 保持一致。</p>
<pre><code class="lang-js">const b = Buffer.from(&apos;abcdef&apos;);

// 传入一个不是有效字节的数字
// 输出：2，相当于搜索 99 或 &apos;c&apos;
console.log(b.lastIndexOf(99.9));
console.log(b.lastIndexOf(256 + 99));

// 传入 byteOffset，其值强制转换为 NaN
// 输出：1，搜索整个 buffer
console.log(b.lastIndexOf(&apos;b&apos;, undefined));
console.log(b.lastIndexOf(&apos;b&apos;, {}));

// 传入 byteOffset，其值强制转换为 0
// 输出：-1，相当于传入 0
console.log(b.lastIndexOf(&apos;b&apos;, null));
console.log(b.lastIndexOf(&apos;b&apos;, []));
</code></pre>
<p>如果 <code>value</code> 是一个空字符串或者空 <code>Buffer</code>，返回 <code>byteOffset</code>。</p>
<h3>buf.length<span><a class="mark" href="#buffer_buf_length" id="buffer_buf_length">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li>
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>返回 <code>buf</code> 在字节数上分配的内存量。
注意，这并不一定反映 <code>buf</code> 内可用的数据量。</p>
<p>例子：创建一个 <code>Buffer</code> 并写入一个较短的 ASCII 字符串。</p>
<pre><code class="lang-js">const buf = Buffer.alloc(1234);

// 输出: 1234
console.log(buf.length);

buf.write(&apos;some string&apos;, 0, &apos;ascii&apos;);

// 输出: 1234
console.log(buf.length);
</code></pre>
<p>虽然 <code>length</code> 属性不是不可变的，但改变 <code>length</code> 的值可能会导致不确定、不一致的行为。
那些希望修改一个 <code>Buffer</code> 的长度的应用程序应当将 <code>length</code> 视为只读的，且使用 <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a> 创建一个新的 <code>Buffer</code>。</p>
<p>例子：</p>
<pre><code class="lang-js">let buf = Buffer.allocUnsafe(10);

buf.write(&apos;abcdefghj&apos;, 0, &apos;ascii&apos;);

// 输出: 10
console.log(buf.length);

buf = buf.slice(0, 5);

// 输出: 5
console.log(buf.length);
</code></pre>
<h3>buf.parent<span><a class="mark" href="#buffer_buf_parent" id="buffer_buf_parent">#</a></span></h3>
<div class="api_metadata">
<span>废弃于: v8.0.0</span>
</div><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">Stability: 0</a> - Deprecated: Use <a href="#buffer_buf_buffer"><code>buf.buffer</code></a> instead.</div><p><code>buf.parent</code> 属性是 <code>buf.buffer</code> 不推荐的别名。</p>
<h3>buf.readDoubleBE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readdoublebe_offset_noassert" id="buffer_buf_readdoublebe_offset_noassert">#</a></span></h3>
<h3>buf.readDoubleLE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readdoublele_offset_noassert" id="buffer_buf_readdoublele_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.11.15</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 8</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;number&gt;</a></li>
</ul>
<p>用指定的字节序格式（<code>readDoubleBE()</code> 返回大端序，<code>readDoubleLE()</code> 返回小端序）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个64位双精度值。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

// 输出: 8.20788039913184e-304
console.log(buf.readDoubleBE());

// 输出: 5.447603722011605e-270
console.log(buf.readDoubleLE());

// 抛出异常: RangeError: Index out of range
console.log(buf.readDoubleLE(1));

// 警告: 读取超出 buffer 的最后一位字节！
// 这会导致内存区段错误！不要这么做！
console.log(buf.readDoubleLE(1, true));
</code></pre>
<h3>buf.readFloatBE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readfloatbe_offset_noassert" id="buffer_buf_readfloatbe_offset_noassert">#</a></span></h3>
<h3>buf.readFloatLE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readfloatle_offset_noassert" id="buffer_buf_readfloatle_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.11.15</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 4</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;number&gt;</a></li>
</ul>
<p>用指定的字节序格式（<code>readFloatBE()</code> 返回大端序，<code>readFloatLE()</code> 返回小端序）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个32位浮点值。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4]);

// 输出: 2.387939260590663e-38
console.log(buf.readFloatBE());

// 输出: 1.539989614439558e-36
console.log(buf.readFloatLE());

// 抛出异常: RangeError: Index out of range
console.log(buf.readFloatLE(1));

// 警告: 读取超出 buffer 的最后一位字节！
// 这会导致内存区段错误！不要这么做！
console.log(buf.readFloatLE(1, true));
</code></pre>
<h3>buf.readInt8(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint8_offset_noassert" id="buffer_buf_readint8_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 1</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取一个有符号的8位整数值。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>从 <code>Buffer</code> 中读取的整数值会被解析为二进制补码值。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([-1, 5]);

// 输出: -1
console.log(buf.readInt8(0));

// 输出: 5
console.log(buf.readInt8(1));

// 抛出异常: RangeError: Index out of range
console.log(buf.readInt8(2));
</code></pre>
<h3>buf.readInt16BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint16be_offset_noassert" id="buffer_buf_readint16be_offset_noassert">#</a></span></h3>
<h3>buf.readInt16LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint16le_offset_noassert" id="buffer_buf_readint16le_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.5</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 2</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>用指定的字节序格式（<code>readInt16BE()</code> 返回大端序，<code>readInt16LE()</code> 返回小端序）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个有符号的16位整数值。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>从 <code>Buffer</code> 中读取的整数值会被解析为二进制补码值。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([0, 5]);

// 输出: 5
console.log(buf.readInt16BE());

// 输出: 1280
console.log(buf.readInt16LE());

// 抛出异常: RangeError: Index out of range
console.log(buf.readInt16LE(1));
</code></pre>
<h3>buf.readInt32BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint32be_offset_noassert" id="buffer_buf_readint32be_offset_noassert">#</a></span></h3>
<h3>buf.readInt32LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint32le_offset_noassert" id="buffer_buf_readint32le_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.5</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 4</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>用指定的字节序格式（<code>readInt32BE()</code> 返回大端序，<code>readInt32LE()</code> 返回小端序）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个有符号的32位整数值。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>从 <code>Buffer</code> 中读取的整数值会被解析为二进制补码值。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([0, 0, 0, 5]);

// 输出: 5
console.log(buf.readInt32BE());

// 输出: 83886080
console.log(buf.readInt32LE());

// 抛出异常: RangeError: Index out of range
console.log(buf.readInt32LE(1));
</code></pre>
<h3>buf.readIntBE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readintbe_offset_bytelength_noassert" id="buffer_buf_readintbe_offset_bytelength_noassert">#</a></span></h3>
<h3>buf.readIntLE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readintle_offset_bytelength_noassert" id="buffer_buf_readintle_offset_bytelength_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.11.15</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - byteLength</code>。</li>
<li><code>byteLength</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要读取的字节数。必须满足：<code>0 &lt; byteLength &lt;= 6</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 和 <code>byteLength</code> 校验？ <strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取 <code>byteLength</code> 个字节，且读取的值会被解析为二进制补码值。
最高支持48位精度。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

// 输出: -546f87a9cbee
console.log(buf.readIntLE(0, 6).toString(16));

// 输出: 1234567890ab
console.log(buf.readIntBE(0, 6).toString(16));

// 抛出异常: RangeError: Index out of range
console.log(buf.readIntBE(1, 6).toString(16));
</code></pre>
<h3>buf.readUInt8(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint8_offset_noassert" id="buffer_buf_readuint8_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 1</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取一个无符号的8位整数值。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([1, -2]);

// 输出: 1
console.log(buf.readUInt8(0));

// 输出: 254
console.log(buf.readUInt8(1));

// 抛出异常: RangeError: Index out of range
console.log(buf.readUInt8(2));
</code></pre>
<h3>buf.readUInt16BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint16be_offset_noassert" id="buffer_buf_readuint16be_offset_noassert">#</a></span></h3>
<h3>buf.readUInt16LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint16le_offset_noassert" id="buffer_buf_readuint16le_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.5</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 2</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>用指定的字节序格式（<code>readUInt16BE()</code> 返回大端序，<code>readUInt16LE()</code> 返回小端序）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个无符号的16位整数值。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56]);

// 输出: 1234
console.log(buf.readUInt16BE(0).toString(16));

// 输出: 3412
console.log(buf.readUInt16LE(0).toString(16));

// 输出: 3456
console.log(buf.readUInt16BE(1).toString(16));

// 输出: 5634
console.log(buf.readUInt16LE(1).toString(16));

// 抛出异常: RangeError: Index out of range
console.log(buf.readUInt16LE(2).toString(16));
</code></pre>
<h3>buf.readUInt32BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint32be_offset_noassert" id="buffer_buf_readuint32be_offset_noassert">#</a></span></h3>
<h3>buf.readUInt32LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint32le_offset_noassert" id="buffer_buf_readuint32le_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.5</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 4</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>用指定的字节序格式（<code>readUInt32BE()</code> 返回大端序，<code>readUInt32LE()</code> 返回小端序）从 <code>buf</code> 中指定的 <code>offset</code> 读取一个无符号的32位整数值。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

// 输出: 12345678
console.log(buf.readUInt32BE(0).toString(16));

// 输出: 78563412
console.log(buf.readUInt32LE(0).toString(16));

// 抛出异常: RangeError: Index out of range
console.log(buf.readUInt32LE(1).toString(16));
</code></pre>
<h3>buf.readUIntBE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readuintbe_offset_bytelength_noassert" id="buffer_buf_readuintbe_offset_bytelength_noassert">#</a></span></h3>
<h3>buf.readUIntLE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readuintle_offset_bytelength_noassert" id="buffer_buf_readuintle_offset_bytelength_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.11.15</span>
</div><ul>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始读取前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - byteLength</code>。</li>
<li><code>byteLength</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要读取的字节数。必须满足：<code>0 &lt; byteLength &lt;= 6</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>offset</code> 和 <code>byteLength</code> 校验？ <strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a></li>
</ul>
<p>从 <code>buf</code> 中指定的 <code>offset</code> 读取 <code>byteLength</code> 个字节，且读取的值会被解析为无符号的整数。
最高支持48位精度。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>offset</code> 可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

// 输出: 1234567890ab
console.log(buf.readUIntBE(0, 6).toString(16));

// 输出: ab9078563412
console.log(buf.readUIntLE(0, 6).toString(16));

//抛出异常: RangeError: Index out of range
console.log(buf.readUIntBE(1, 6).toString(16));
</code></pre>
<h3>buf.slice([start[, end]])<span><a class="mark" href="#buffer_buf_slice_start_end" id="buffer_buf_slice_start_end">#</a></span></h3>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v7.1.0, v6.9.2</td>
<td><p>Coercing the offsets to integers now handles values outside the 32-bit integer range properly.</p>
</td></tr>
<tr><td>v7.0.0</td>
<td><p>All offsets are now coerced to integers before doing any calculations with them.</p>
</td></tr>
<tr><td>v0.3.0</td>
<td><p><span>新增于: v0.3.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>start</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 新建的 <code>Buffer</code> 开始的位置。 <strong>默认:</strong> <code>0</code></li>
<li><code>end</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 新建的 <code>Buffer</code> 结束的位置（不包含）。
<strong>默认:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>返回: 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>返回一个指向相同原始内存的新建的 <code>Buffer</code>，但做了偏移且通过 <code>start</code> 和 <code>end</code> 索引进行裁剪。</p>
<p>指定大于<a href="#buffer_buf_length"><code>buf.length</code></a>的结束值，与结束值设置为<a href="#buffer_buf_length"><code>buf.length</code></a>的结果一样。</p>
<p><strong>注意，修改这个新建的 <code>Buffer</code> 切片，也会同时修改原始的 <code>Buffer</code> 的内存，因为这两个对象所分配的内存是重叠的。</strong></p>
<p>例子：创建一个包含 ASCII 字母表的 <code>Buffer</code>，并进行切片，然后修改原始 <code>Buffer</code> 上的一个字节。</p>
<pre><code class="lang-js">const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 是 &apos;a&apos; 的十进制 ASCII 值 
  buf1[i] = i + 97;
}

const buf2 = buf1.slice(0, 3);

// 输出: abc
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));

buf1[0] = 33;

// 输出: !bc
console.log(buf2.toString(&apos;ascii&apos;, 0, buf2.length));
</code></pre>
<p>指定负的索引会导致切片的生成是相对于 <code>buf</code> 的末尾而不是开头。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from(&apos;buffer&apos;);

// 输出: buffe
// (相当于 buf.slice(0, 5))
console.log(buf.slice(-6, -1).toString());

// 输出: buff
// (相当于 buf.slice(0, 4))
console.log(buf.slice(-6, -2).toString());

// 输出: uff
// (相当于 buf.slice(1, 4))
console.log(buf.slice(-5, -2).toString());
</code></pre>
<h3>buf.swap16()<span><a class="mark" href="#buffer_buf_swap16" id="buffer_buf_swap16">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.10.0</span>
</div><ul>
<li>返回: 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> <code>buf</code> 的引用</li>
</ul>
<p>将 <code>buf</code> 解析为一个无符号16位的整数数组，并且以字节顺序原地进行交换。
如果 <a href="#buffer_buf_length"><code>buf.length</code></a> 不是2的倍数，则抛出 <code>RangeError</code> 错误。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
console.log(buf1);

buf1.swap16();

// 输出: &lt;Buffer 02 01 04 03 06 05 08 07&gt;
console.log(buf1);


const buf2 = Buffer.from([0x1, 0x2, 0x3]);

// 抛出异常: RangeError: Buffer size must be a multiple of 16-bits
buf2.swap16();
</code></pre>
<h3>buf.swap32()<span><a class="mark" href="#buffer_buf_swap32" id="buffer_buf_swap32">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v5.10.0</span>
</div><ul>
<li>返回: 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> <code>buf</code> 的引用</li>
</ul>
<p>将 <code>buf</code> 解析为一个无符号32位的整数数组，并且以字节顺序原地进行交换。
如果 <a href="#buffer_buf_length"><code>buf.length</code></a> 不是4的倍数，则抛出 <code>RangeError</code> 错误。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
console.log(buf1);

buf1.swap32();

// 输出: &lt;Buffer 04 03 02 01 08 07 06 05&gt;
console.log(buf1);


const buf2 = Buffer.from([0x1, 0x2, 0x3]);

// 抛出异常: RangeError: Buffer size must be a multiple of 32-bits
buf2.swap32();
</code></pre>
<h3>buf.swap64()<span><a class="mark" href="#buffer_buf_swap64" id="buffer_buf_swap64">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v6.3.0</span>
</div><ul>
<li>返回: 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> <code>buf</code> 的引用</li>
</ul>
<p>将 <code>buf</code> 解析为一个64位的数值数组，并且以字节顺序原地进行交换。
如果 <a href="#buffer_buf_length"><code>buf.length</code></a> 不是8的倍数，则抛出 <code>RangeError</code> 错误。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;
console.log(buf1);

buf1.swap64();

// 输出: &lt;Buffer 08 07 06 05 04 03 02 01&gt;
console.log(buf1);


const buf2 = Buffer.from([0x1, 0x2, 0x3]);

// 抛出异常: RangeError: Buffer size must be a multiple of 64-bits
buf2.swap64();
</code></pre>
<p>注意，JavaScript 不能编码64位整数。
该方法是用来处理64位浮点数的。</p>
<h3>buf.toJSON()<span><a class="mark" href="#buffer_buf_tojson" id="buffer_buf_tojson">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.9.2</span>
</div><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;Object&gt;</a></li>
</ul>
<p>返回 <code>buf</code> 的 JSON 格式。
当字符串化一个 <code>Buffer</code> 实例时，<a href="javascript:;"><code>JSON.stringify()</code></a> 会隐式地调用该函数。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

// 输出: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}
console.log(json);

const copy = JSON.parse(json, (key, value) =&gt; {
  return value &amp;&amp; value.type === &apos;Buffer&apos; ?
    Buffer.from(value.data) :
    value;
});

// 输出: &lt;Buffer 01 02 03 04 05&gt;
console.log(copy);
</code></pre>
<h3>buf.toString([encoding[, start[, end]]])<span><a class="mark" href="#buffer_buf_tostring_encoding_start_end" id="buffer_buf_tostring_encoding_start_end">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 解码使用的字符编码。<strong>默认:</strong> <code>&apos;utf8&apos;</code></li>
<li><code>start</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始解码的字节偏移量。<strong>默认:</strong> <code>0</code></li>
<li><code>end</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 结束解码的字节偏移量（不包含）。
<strong>默认:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;string&gt;</a></li>
</ul>
<p>根据 <code>encoding</code> 指定的字符编码解码 <code>buf</code> 成一个字符串。
<code>start</code> 和 <code>end</code> 可传入用于只解码 <code>buf</code> 的一部分。</p>
<p>字符串实例的最大长度（以UTF-16代码为单位）可查看<a href="#buffer_buffer_constants_max_string_length"><code>buffer.constants.MAX_STRING_LENGTH</code></a>。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i &lt; 26; i++) {
  // 97 是 &apos;a&apos; 的十进制 ASCII 值
  buf1[i] = i + 97;
}

// 输出: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString(&apos;ascii&apos;));

// 输出: abcde
console.log(buf1.toString(&apos;ascii&apos;, 0, 5));


const buf2 = Buffer.from(&apos;tést&apos;);

// 输出: 74c3a97374
console.log(buf2.toString(&apos;hex&apos;));

// 输出: té
console.log(buf2.toString(&apos;utf8&apos;, 0, 3));

// 输出: té
console.log(buf2.toString(undefined, 0, 3));
</code></pre>
<h3>buf.values()<span><a class="mark" href="#buffer_buf_values" id="buffer_buf_values">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v1.1.0</span>
</div><ul>
<li>返回: 
            <a href="javascript:;" class="type">&lt;Iterator&gt;</a></li>
</ul>
<p>创建并返回一个包含 <code>buf</code> 的值（字节）的<a href="javascript:;">迭代器</a>。
当 <code>Buffer</code> 使用 <code>for..of</code> 时会自动调用该函数。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.from(&apos;buffer&apos;);

// 输出:
//   98
//   117
//   102
//   102
//   101
//   114
for (const value of buf.values()) {
  console.log(value);
}

// 输出:
//   98
//   117
//   102
//   102
//   101
//   114
for (const value of buf) {
  console.log(value);
}
</code></pre>
<h3>buf.write(string[, offset[, length]][, encoding])<span><a class="mark" href="#buffer_buf_write_string_offset_length_encoding" id="buffer_buf_write_string_offset_length_encoding">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.1.90</span>
</div><ul>
<li><code>string</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 要写入 <code>buf</code> 的字符串。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入 <code>string</code> 前要跳过的字节数。<strong>默认:</strong> <code>0</code>。</li>
<li><code>length</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入的字节数。<strong>默认:</strong> <code>buf.length - offset</code>。</li>
<li><code>encoding</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> <code>string</code> 的字符编码。<strong>默认:</strong> <code>&apos;utf8&apos;</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 写入的字节数。</li>
</ul>
<p>根据 <code>encoding</code> 的字符编码写入 <code>string</code> 到 <code>buf</code> 中的 <code>offset</code> 位置。
<code>length</code> 参数是写入的字节数。
如果 <code>buf</code> 没有足够的空间保存整个字符串，则只会写入 <code>string</code> 的一部分。
只部分解码的字符不会被写入。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(256);

const len = buf.write(&apos;\u00bd + \u00bc = \u00be&apos;, 0);

// 输出: 12 个字节: ½ + ¼ = ¾
console.log(`${len} 个字节: ${buf.toString(&apos;utf8&apos;, 0, len)}`);
</code></pre>
<h3>buf.writeDoubleBE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writedoublebe_value_offset_noassert" id="buffer_buf_writedoublebe_value_offset_noassert">#</a></span></h3>
<h3>buf.writeDoubleLE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writedoublele_value_offset_noassert" id="buffer_buf_writedoublele_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.11.15</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 8</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code> 和 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>用指定的字节序格式（<code>writeDoubleBE()</code> 写入大端序，<code>writeDoubleLE()</code> 写入小端序）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。
<code>value</code> 应当是一个有效的64位双精度值。
当 <code>value</code> 不是一个64位双精度值时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

// 输出: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

// 输出: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;
console.log(buf);
</code></pre>
<h3>buf.writeFloatBE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writefloatbe_value_offset_noassert" id="buffer_buf_writefloatbe_value_offset_noassert">#</a></span></h3>
<h3>buf.writeFloatLE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writefloatle_value_offset_noassert" id="buffer_buf_writefloatle_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.11.15</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;number&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 4</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code> 和 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>用指定的字节序格式（<code>writeFloatBE()</code> 写入大端序，<code>writeFloatLE()</code> 写入小端序）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。
<code>value</code> 应当是一个有效的32位浮点值。
当 <code>value</code> 不是一个32位浮点值时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeFloatBE(0xcafebabe, 0);

// 输出: &lt;Buffer 4f 4a fe bb&gt;
console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

// 输出: &lt;Buffer bb fe 4a 4f&gt;
console.log(buf);
</code></pre>
<h3>buf.writeInt8(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint8_value_offset_noassert" id="buffer_buf_writeint8_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 1</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code> 和 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。
<code>value</code> 应当是一个有效的有符号的8位整数。
当 <code>value</code> 不是一个有符号的8位整数时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>
<p><code>value</code> 会被解析并写入为二进制补码值。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(2);

buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);

// 输出: &lt;Buffer 02 fe&gt;
console.log(buf);
</code></pre>
<h3>buf.writeInt16BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint16be_value_offset_noassert" id="buffer_buf_writeint16be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt16LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint16le_value_offset_noassert" id="buffer_buf_writeint16le_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.5</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 2</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code> 和 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>用指定的字节序格式（<code>writeInt16BE()</code> 写入大端序，<code>writeInt16LE()</code> 写入小端序）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。
<code>value</code> 应当是一个有效的有符号的16位整数。
当 <code>value</code> 不是一个有符号的16位整数时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p><code>value</code> 会被解析并写入为二进制补码值。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeInt16BE(0x0102, 0);
buf.writeInt16LE(0x0304, 2);

// 输出: &lt;Buffer 01 02 04 03&gt;
console.log(buf);
</code></pre>
<h3>buf.writeInt32BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint32be_value_offset_noassert" id="buffer_buf_writeint32be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt32LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint32le_value_offset_noassert" id="buffer_buf_writeint32le_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.5</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 4</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code> 和 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>用指定的字节序格式（<code>writeInt32BE()</code> 写入大端序，<code>writeInt32LE()</code> 写入小端序）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。
<code>value</code> 应当是一个有效的有符号的32位整数。
当 <code>value</code> 不是一个有符号的32位整数时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p><code>value</code> 会被解析并写入为二进制补码值。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeInt32BE(0x01020304, 0);
buf.writeInt32LE(0x05060708, 4);

// 输出: &lt;Buffer 01 02 03 04 08 07 06 05&gt;
console.log(buf);
</code></pre>
<h3>buf.writeIntBE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeintbe_value_offset_bytelength_noassert" id="buffer_buf_writeintbe_value_offset_bytelength_noassert">#</a></span></h3>
<h3>buf.writeIntLE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeintle_value_offset_bytelength_noassert" id="buffer_buf_writeintle_value_offset_bytelength_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.11.15</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - byteLength</code>。</li>
<li><code>byteLength</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入的字节数，必须满足：<code>0 &lt; byteLength &lt;= 6</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code>、<code>offset</code> 和 <code>byteLength</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>写入 <code>value</code> 中的 <code>byteLength</code> 个字节到 <code>buf</code> 中指定的 <code>offset</code> 位置。
最高支持48位精度。
当 <code>value</code> 不是一个有符号的整数时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeIntBE(0x1234567890ab, 0, 6);

// 输出: &lt;Buffer 12 34 56 78 90 ab&gt;
console.log(buf);

buf.writeIntLE(0x1234567890ab, 0, 6);

// 输出: &lt;Buffer ab 90 78 56 34 12&gt;
console.log(buf);
</code></pre>
<h3>buf.writeUInt8(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint8_value_offset_noassert" id="buffer_buf_writeuint8_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 1</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code> 和 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。
<code>value</code> 应当是一个有效的无符号的8位整数。
当 <code>value</code> 不是一个无符号的8位整数时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

// 输出: &lt;Buffer 03 04 23 42&gt;
console.log(buf);
</code></pre>
<h3>buf.writeUInt16BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint16be_value_offset_noassert" id="buffer_buf_writeuint16be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt16LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint16le_value_offset_noassert" id="buffer_buf_writeuint16le_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.5</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 2</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code> 和 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>用指定的字节序格式（<code>writeUInt16BE()</code> 写入大端序，<code>writeUInt16LE()</code> 写入小端序）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。
<code>value</code> 应当是一个有效的无符号的16位整数。
当 <code>value</code> 不是一个无符号的16位整数时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

// 输出: &lt;Buffer de ad be ef&gt;
console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

// 输出: &lt;Buffer ad de ef be&gt;
console.log(buf);
</code></pre>
<h3>buf.writeUInt32BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint32be_value_offset_noassert" id="buffer_buf_writeuint32be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt32LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint32le_value_offset_noassert" id="buffer_buf_writeuint32le_value_offset_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.5</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - 4</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code> 和 <code>offset</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>用指定的字节序格式（<code>writeUInt32BE()</code> 写入大端序，<code>writeUInt32LE()</code> 写入小端序）写入 <code>value</code> 到 <code>buf</code> 中指定的 <code>offset</code> 位置。
<code>value</code> 应当是一个有效的无符号的32位整数。
当 <code>value</code> 不是一个无符号的32位整数时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的最后一位字节，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt32BE(0xfeedface, 0);

// 输出: &lt;Buffer fe ed fa ce&gt;
console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

// 输出: &lt;Buffer ce fa ed fe&gt;
console.log(buf);
</code></pre>
<h3>buf.writeUIntBE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeuintbe_value_offset_bytelength_noassert" id="buffer_buf_writeuintbe_value_offset_bytelength_noassert">#</a></span></h3>
<h3>buf.writeUIntLE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeuintle_value_offset_bytelength_noassert" id="buffer_buf_writeuintle_value_offset_bytelength_noassert">#</a></span></h3>
<div class="api_metadata">
<span>新增于: v0.5.5</span>
</div><ul>
<li><code>value</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入 <code>buf</code> 的数值。</li>
<li><code>offset</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 开始写入前要跳过的字节数，必须满足：<code>0 &lt;= offset &lt;= buf.length - byteLength</code>。</li>
<li><code>byteLength</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 要写入的字节数，必须满足：<code>0 &lt; byteLength &lt;= 6</code>。</li>
<li><code>noAssert</code> 
            <a href="javascript:;" class="type">&lt;boolean&gt;</a> 是否跳过 <code>value</code>、<code>offset</code> 和 <code>byteLength</code> 检验？<strong>默认:</strong> <code>false</code>。</li>
<li>返回: 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> <code>offset</code> 加上写入的字节数。</li>
</ul>
<p>写入 <code>value</code> 中的 <code>byteLength</code> 个字节到 <code>buf</code> 中指定的 <code>offset</code> 位置。
最高支持48位精度。
当 <code>value</code> 不是一个无符号的整数时，反应是不确定的。</p>
<p>设置 <code>noAssert</code> 为 <code>true</code> 则 <code>value</code> 的编码形式可超出 <code>buf</code> 的末尾，但后果是不确定的。</p>
<p>例子：</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

// 输出: &lt;Buffer 12 34 56 78 90 ab&gt;
console.log(buf);

buf.writeUIntLE(0x1234567890ab, 0, 6);

// 输出: &lt;Buffer ab 90 78 56 34 12&gt;
console.log(buf);
</code></pre>
<h2>buffer.INSPECT_MAX_BYTES<span><a class="mark" href="#buffer_buffer_inspect_max_bytes" id="buffer_buffer_inspect_max_bytes">#</a></span></h2>
<div class="api_metadata">
<span>新增于: v0.5.4</span>
</div><ul>
<li>
            <a href="javascript:;" class="type">&lt;Integer&gt;</a> <strong>默认:</strong> <code>50</code></li>
</ul>
<p>当调用 <code>buf.inspect()</code> 时返回的最大字节数。
可以被用户模块重写。
详见 <a href="util.html#util_util_inspect_object_options"><code>util.inspect()</code></a> 了解更多 <code>buf.inspect()</code> 的行为。</p>
<p>注意，这个属性是在通过 <code>require(&apos;buffer&apos;)</code> 返回的 <code>buffer</code> 模块上，而不是在 <code>Buffer</code> 的全局变量或 <code>Buffer</code> 实例上。</p>
<h2>buffer.kMaxLength<span><a class="mark" href="#buffer_buffer_kmaxlength" id="buffer_buffer_kmaxlength">#</a></span></h2>
<div class="api_metadata">
<span>新增于: v3.0.0</span>
</div><ul>
<li>
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 分配给单个 <code>Buffer</code> 实例的最大内存</li>
</ul>
<p>An alias for <a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a></p>
<p>注意整个属性是通过 <code>require(&apos;buffer&apos;)</code> 返回的 <code>buffer</code> 模块的属性，而不是全局 <code>Buffer</code> 对象或 <code>Buffer</code> 实例的属性。</p>
<h2>buffer.transcode(source, fromEnc, toEnc)<span><a class="mark" href="#buffer_buffer_transcode_source_fromenc_toenc" id="buffer_buffer_transcode_source_fromenc_toenc">#</a></span></h2>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>source</code> parameter can now be a <code>Uint8Array</code>.</p>
</td></tr>
<tr><td>v7.1.0</td>
<td><p><span>新增于: v7.1.0</span></p>
</td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>source</code> 
            <a href="#buffer_class_buffer" class="type">&lt;Buffer&gt;</a> | 
            <a href="javascript:;" class="type">&lt;Uint8Array&gt;</a> 一个 <code>Buffer</code> 或 <code>Uint8Array</code> 实例</li>
<li><code>fromEnc</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 当前编码</li>
<li><code>toEnc</code> 
            <a href="javascript:;" class="type">&lt;string&gt;</a> 目标编码</li>
</ul>
<p>将给定的 <code>Buffer</code> 或 <code>Uint8Array</code> 实例从一个字符编码重新编码到另一个字符。 返回一个新的Buffer实例。</p>
<p>如果 <code>fromEnc</code> 或 <code>toEnc</code> 指定的字符串编码无效，或者不允许从 <code>fromEnc</code> 转换为 <code>toEnc</code>，将抛出异常。</p>
<p>如果给定的字节序列不能在目标编码中充分表示，转码过程将使用替代字符。例如：</p>
<pre><code class="lang-js">const buffer = require(&apos;buffer&apos;);

const newBuf = buffer.transcode(Buffer.from(&apos;€&apos;), &apos;utf8&apos;, &apos;ascii&apos;);
console.log(newBuf.toString(&apos;ascii&apos;));
// 输出: &apos;?&apos;
</code></pre>
<p>因为欧元符号（<code>€</code>）不能在 US-ASCII 中表示，所以在转换 <code>Buffer</code> 的时候使用 <code>?</code> 代替。</p>
<p>注意 <code>buffer</code> 属性是通过 <code>require(&apos;buffer&apos;)</code> 返回的 <code>buffer</code> 模块，而不是全局 <code>Buffer</code> 或 <code>Buffer</code> 实例的属性。</p>
<h2>SlowBuffer 类<span><a class="mark" href="#buffer_class_slowbuffer" id="buffer_class_slowbuffer">#</a></span></h2>
<div class="api_metadata">
<span>废弃于: v6.0.0</span>
</div><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 废弃的: 使用 <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> 代替。</div><p>返回一个不放入分配池的 <code>Buffer</code>。</p>
<p>为了避免垃圾回收机制因创建太多独立分配的 Buffer 实例而过度使用，默认小于 4KB 的内存会从一个单一的大内存中切割出来。</p>
<p>开发者可能需要在不确定的时间段从内存池保留一小块内存的情况下，针对这种情况，就可以使用 <code>SlowBuffer</code> 类创建不放入分配池 <code>Buffer</code> 实例，然后通过内存拷贝获取目标数据。</p>
<p>例子:</p>
<pre><code class="lang-js">// 需要保存的一小块内存
const store = [];

socket.on(&apos;readable&apos;, () =&gt; {
  const data = socket.read();

  // 为保留的数据分配内存
  const sb = SlowBuffer(10);

  // 将数据复制到新的分配的内存中
  data.copy(sb, 0, 0, 10);

  store.push(sb);
});
</code></pre>
<p><code>SlowBuffer</code> 应当仅仅作为开发者已经在他们的应用程序中观察到过度的内存保留之后的终极手段使用。</p>
<h3>new SlowBuffer(size)<span><a class="mark" href="#buffer_new_slowbuffer_size" id="buffer_new_slowbuffer_size">#</a></span></h3>
<div class="api_metadata">
<span>废弃于: v6.0.0</span>
</div><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 废弃的: 使用 <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> 代替。</div><ul>
<li><code>size</code> 
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 新建的 <code>SlowBuffer</code> 期望的长度</li>
</ul>
<p>分配一个 <code>size</code> 字节的新的 <code>Buffer</code>。如果 <code>size</code> 大于 <a href="#buffer_buffer_constants_max_length"><code>buffer.constants.MAX_LENGTH</code></a> 或小于 0，将会抛出 <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> 错误。如果 <code>size</code> 为 0，则返回一个为 0 的 <code>Buffer</code>.</p>
<p><code>SlowBuffer</code> 实例的底层内存是 <em>未初始化的</em>。新建的 <code>SlowBuffer</code> 的内容是未知的，并且可能包含敏感数据。使用 <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> 初始化 <code>SlowBuffer</code> 为 0。</p>
<p>例子:</p>
<pre><code class="lang-js">const { SlowBuffer } = require(&apos;buffer&apos;);

const buf = new SlowBuffer(5);

// 输出: (内容可能有变化): &lt;Buffer 78 e0 82 02 01&gt;
console.log(buf);

buf.fill(0);

// 输出: &lt;Buffer 00 00 00 00 00&gt;
console.log(buf);
</code></pre>
<h2>Buffer Constants<span><a class="mark" href="#buffer_buffer_constants" id="buffer_buffer_constants">#</a></span></h2>
<div class="api_metadata">
<span>新增于: 8.2.0</span>
</div><p>请注意<code>buffer.constants</code>是通过<code>require(&apos;buffer&apos;)</code>返回的<code>buffer</code>模块的一个属性，而不是全局<code>Buffer</code>或<code>Buffer</code>实例。 </p>
<h3>buffer.constants.MAX_LENGTH<span><a class="mark" href="#buffer_buffer_constants_max_length" id="buffer_buffer_constants_max_length">#</a></span></h3>
<div class="api_metadata">
<span>新增于: 8.2.0</span>
</div><ul>
<li>
            <a href="javascript:;" class="type">&lt;integer&gt;</a>  单个<code>Buffer</code>实例允许的最大量度。</li>
</ul>
<p>在32位体系结构上，这个值是<code>(2^30)-1</code> (~1GB)。
在64位体系结构上，这个值是<code>(2^31)-1</code> (~2GB)。</p>
<p>也可在<a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>查看该值。</p>
<h3>buffer.constants.MAX_STRING_LENGTH<span><a class="mark" href="#buffer_buffer_constants_max_string_length" id="buffer_buffer_constants_max_string_length">#</a></span></h3>
<div class="api_metadata">
<span>新增于: 8.2.0</span>
</div><ul>
<li>
            <a href="javascript:;" class="type">&lt;integer&gt;</a> 单个<code>string</code>实例允许的最大长度。</li>
</ul>
<p>代表<code>string</code>能有的原始最大<code>长度</code>，以UTF-16代码为单位。</p>
<p>该值可能取决于正在使用的JS引擎。</p>

      </div>
    </div>

    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="index.html" title="Go back to the home page">
          Node.js 中文文档 | Node.js 中文网
        </a>
      </div>
      
        <!-- [start-include:_toc.md] -->
<ul>
<li><a href="documentation.html">关于本文档</a></li>
<li><a href="synopsis.html">用法与例子</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a href="assert.html">断言测试</a></li>
<li><a href="async_hooks.html">异步钩子（Async Hooks）</a></li>
<li><a href="">缓存（Buffer）</a></li>
<li><a href="addons.html">C++ 插件</a></li>
<li><a href="n-api.html">C/C++ 插件 - N-API</a></li>
<li><a href="child_process.html">子进程</a></li>
<li><a href="cluster.html">集群（Cluster）</a></li>
<li><a href="cli.html">命令行参数</a></li>
<li><a href="console.html">控制台（Console）</a></li>
<li><a href="crypto.html">加密（Crypto）</a></li>
<li><a href="debugger.html">调试器</a></li>
<li><a href="deprecations.html">废弃的 API</a></li>
<li><a href="dns.html">DNS</a></li>
<li><a href="domain.html">域（Domain）</a></li>
<li><a href="esm.html">ECMAScript 模块</a></li>
<li><a href="errors.html">错误（Errors）</a></li>
<li><a href="events.html">事件（Events）</a></li>
<li><a href="fs.html">文件系统</a></li>
<li><a href="globals.html">全局对象（Globals）</a></li>
<li><a href="http.html">HTTP</a></li>
<li><a href="http2.html">HTTP/2</a></li>
<li><a href="https.html">HTTPS</a></li>
<li><a href="inspector.html">检查工具（Inspector）</a></li>
<li><a href="intl.html">国际化</a></li>
<li><a href="modules.html">模块（Modules）</a></li>
<li><a href="net.html">网络（Net）</a></li>
<li><a href="os.html">操作系统（OS）</a></li>
<li><a href="path.html">路径（Path）</a></li>
<li><a href="perf_hooks.html">性能钩子（Performance Hooks）</a></li>
<li><a href="process.html">进程</a></li>
<li><a href="punycode.html">Punycode</a></li>
<li><a href="querystring.html">查询字符串</a></li>
<li><a href="readline.html">逐行读取</a></li>
<li><a href="repl.html">交互式解释器（REPL）</a></li>
<li><a href="stream.html">流（Stream）</a></li>
<li><a href="string_decoder.html">字符串解码</a></li>
<li><a href="timers.html">定时器（Timers）</a></li>
<li><a href="tls.html">安全传输层（TLS/SSL）</a></li>
<li><a href="tracing.html">事件跟踪（Tracing）</a></li>
<li><a href="tty.html">TTY</a></li>
<li><a href="dgram.html">UDP / 数据报</a></li>
<li><a href="url.html">URL</a></li>
<li><a href="util.html">工具集</a></li>
<li><a href="v8.html">V8</a></li>
<li><a href="vm.html">虚拟机（VM）</a></li>
<li><a href="zlib.html">压缩（ZLIB）</a></li>
</ul>
<div class="line"></div>

<ul>
<li><a href="javascript:;">GitHub 仓库和问题跟踪</a></li>
<li><a href="javascript:;">邮件列表</a></li>
</ul>
<!-- [end-include:_toc.md] -->

      
    </div>
  </div>
  <script src="static/js/sh_main.js"></script>
  <script src="static/js/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>
